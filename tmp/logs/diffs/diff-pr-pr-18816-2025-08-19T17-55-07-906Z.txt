{
  "pullRequestId": 18816,
  "sourceCommit": "560d522af8587bacb7a5da88bd55fc0124a5c87d",
  "targetCommit": "71176c6f1376191e2c2b16b0261983c607f09190",
  "files": [
    {
      "filePath": "/__mocks__/@react-native-community/geolocation.js",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__mocks__/@react-native-community/geolocation.js",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 9,
          "content": "+export default {\n+    addListener: jest.fn(),\n+    getCurrentPosition: jest.fn(),\n+    removeListeners: jest.fn(),\n+    requestAuthorization: jest.fn(),\n+    setConfiguration: jest.fn(),\n+    startObserving: jest.fn(),\n+    stopObserving: jest.fn()\n+  };",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/location-helper.test.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/location-helper.test.ts",
          "changeType": "edit",
          "oldLineStart": 1,
          "oldLineCount": 97,
          "newLineStart": 1,
          "newLineCount": 591,
          "content": "-import Geolocation, { GeolocationError, GeolocationResponse } from \"@react-native-community/geolocation\";\n+import { isEmulator } from \"react-native-device-info\";\n+import { isMockingLocation } from \"react-native-turbo-mock-location-detector\";\n+import type { GeolocationError, GeolocationResponse } from \"@react-native-community/geolocation\";\n \n-import { getCurrentPosition } from \"../../../app/lib/location-helper\";\n+import { ApiResponseContextType } from \"../../../app/context/ApiResponseContext\";\n+import { UnitCreateLocationModalLocationProps } from \"../../../app/features/units/components/unit-create-location-modal/type\";\n \n-jest.mock(\"@react-native-community/geolocation\", () => ({\n-  getCurrentPosition: jest.fn()\n+let LocationHelper: typeof import(\"../../../app/lib/location-helper\");\n+\n+jest.mock(\"../../../app/lib/location-helper\", () => ({\n+  ...jest.requireActual(\"../../../app/lib/location-helper\"),\n+  getDestinationsAndWaypoints: jest.fn(),\n+}));\n+\n+jest.mock(\"../../../app/lib/common-methods\", () => ({\n+  replaceTurkishSpecialChars: jest.fn((str: string) => {\n+    return str\n+      .replace(/İ/g, \"I\")\n+      .replace(/ı/g, \"i\")\n+      .replace(/Ğ/g, \"G\")\n+      .replace(/ğ/g, \"g\")\n+      .replace(/Ü/g, \"U\")\n+      .replace(/ü/g, \"u\")\n+      .replace(/Ş/g, \"S\")\n+      .replace(/ş/g, \"s\")\n+      .replace(/Ö/g, \"O\")\n+      .replace(/ö/g, \"o\")\n+      .replace(/Ç/g, \"C\")\n+      .replace(/ç/g, \"c\");\n+  }),\n+  removeDuplicatedData: jest.fn((arr: any[], key: string) => {\n+    const seen = new Set();\n+    return arr.filter((item: any) => !seen.has(item[key]) && (seen.add(item[key]) || true));\n+  }),\n+}));\n+\n+jest.mock(\"../../../app/lib/static-text-helper\", () => ({\n+  getTextSync: jest.fn((key: string) => {\n+    const texts: Record<string, string> = {\n+      LocationOffAlertMessage: \"Konum servisleriniz kapalı.\",\n+      LocationSettingsAlertMessage: \"Konum izni verilmemiş.\",\n+      Ok: \"Tamam\",\n+      Cancel: \"İptal\"\n+    };\n+    return texts[key] || \"\";\n+  })\n }));\n \n+jest.mock(\"../../../app/lib/ios-permissions\", () => ({\n+  checkLocationPermission: jest.fn()\n+}));\n+jest.mock(\"react-native-device-info\", () => ({\n+  isEmulator: jest.fn()\n+}));\n+jest.mock(\"react-native-turbo-mock-location-detector\", () => ({\n+  isMockingLocation: jest.fn()\n+}));\n+jest.mock(\"../../../app/lib/android-permissions\", () => ({\n+  checkLocationPermission: jest.fn(),\n+  requestEnableLocation: jest.fn()\n+}));\n jest.mock(\"../../../app/config/configurations\", () => ({\n   STATIC_TEXTS: {\n     tr: {\n-      LocationOffAlertMessage: \"Location is off\",\n-      LocationSettingsAlertMessage: \"Location permission denied\",\n-      Ok: \"Ok\",\n-      Cancel: \"Cancel\"\n+      LocationOffAlertMessage: \"Konum servisleriniz kapalı.\",\n+      LocationSettingsAlertMessage: \"Konum izni verilmemiş.\",\n+      Ok: \"Tamam\",\n+      Cancel: \"İptal\"\n     }\n   },\n   ENV: {\n     ENCRYPTION_HASH_SECRET_KEY: \"test\"\n   }\n }));\n+jest.mock(\"../../../app/lib/distance-service\", () => ({\n+  sortByDistance: jest.fn((origin, destinations) => {\n+    return [...destinations].sort((a: any, b: any) => {\n+      const distA = Math.sqrt(Math.pow(a.latitude - origin.latitude, 2) + Math.pow(a.longitude - origin.longitude, 2));\n+      const distB = Math.sqrt(Math.pow(b.latitude - origin.latitude, 2) + Math.pow(b.longitude - origin.longitude, 2));\n+      return distA - distB;\n+    });\n+  })\n+}));\n+jest.mock(\"../../../app/lib/linking-helper\", () => ({\n+  openSettingsURL: jest.fn(),\n+  openAppSettings: jest.fn(),\n+  SETTINGS_URLS: {\n+    IosPrivacySettings: \"app-settings:privacy\"\n+  }\n+}));\n+\n+const mockPlatformOS = (os: \"ios\" | \"android\") => {\n+  jest.doMock(\"react-native\", () => {\n+    const actualRN = jest.requireActual(\"react-native\");\n+    return {\n+      ...actualRN,\n+      Alert: { alert: jest.fn() },\n+      Platform: {\n+        OS: os,\n+        select: (obj: any) => obj[os],\n+        Version: actualRN.Platform.Version || 29,\n+      },\n+      PermissionsAndroid: {\n+        RESULTS: { GRANTED: 'granted', DENIED: 'denied', NEVER_ASK_AGAIN: 'never_ask_again' },\n+        check: jest.fn(),\n+        request: jest.fn(),\n+      },\n+    };\n+  });\n+};\n+\n+const mockApiResponseContext: ApiResponseContextType = {\n+  setError: jest.fn(),\n+  setSuccess: jest.fn(),\n+  setWarning: jest.fn(),\n+  resetContext: jest.fn(),\n+  setErrorToastShown: jest.fn(),\n+  state: {\n+    show: false,\n+    message: \"\"\n+  } as any\n+};\n \n-describe(\"getCurrentPosition\", () => {\n-  it(\"should resolve with success and location data when geolocation is successful\", async () => {\n-    const mockGeolocation = Geolocation as jest.Mocked<typeof Geolocation>;\n-    mockGeolocation.getCurrentPosition.mockImplementationOnce(success => success({ coords: { latitude: 123, longitude: 456 } as any, timestamp: Date.now() }));\n+global.fetch = jest.fn(() =>\n+  Promise.resolve({\n+    json: () => Promise.resolve({})\n+  })\n+) as jest.Mock;\n \n-    const result = await getCurrentPosition();\n+describe(\"location-helper\", () => {\n+  let Alert: typeof import(\"react-native\").Alert;\n+  let Geolocation: typeof import(\"@react-native-community/geolocation\").default;\n+  let AndroidPermissions: typeof import(\"../../../app/lib/android-permissions\");\n+  let IosPermissions: typeof import(\"../../../app/lib/ios-permissions\");\n \n-    expect(result.success).toBe(true);\n-    expect(result.result.latitude).toBe(123);\n-    expect(result.result.longitude).toBe(456);\n+  beforeEach(() => {\n+    jest.clearAllMocks();\n+    jest.resetModules();\n+    mockPlatformOS(\"android\");\n+    LocationHelper = require(\"../../../app/lib/location-helper\");\n+    Alert = require(\"react-native\").Alert;\n+    AndroidPermissions = require(\"../../../app/lib/android-permissions\");\n+    IosPermissions = require(\"../../../app/lib/ios-permissions\");\n+    Geolocation = require(\"@react-native-community/geolocation\").default;\n+    LocationHelper.getDestinationsAndWaypoints = jest.fn();\n   });\n \n-  it(\"should resolve with error when geolocation fails\", async () => {\n-    const mockGeolocation = Geolocation as jest.Mocked<typeof Geolocation>;\n+  describe(\"getCurrentPosition\", () => {\n+    it(\"should resolve with success and location data when geolocation is successful\", async () => {\n+      (Geolocation.getCurrentPosition as jest.Mock).mockImplementation(\n+        (success: (position: GeolocationResponse) => void) => {\n+          success({\n+            coords: {\n+              latitude: 123,\n+              longitude: 456,\n+              accuracy: 10,\n+              altitude: null,\n+              altitudeAccuracy: null,\n+              heading: null,\n+              speed: null,\n+            },\n+            timestamp: Date.now(),\n+          });\n+        }\n+      );\n \n-    const mockError = {\n-      code: 1,\n-      message: \"Location error\"\n-    } as any;\n+      const result = await LocationHelper.getCurrentPosition();\n+      expect(result.success).toBe(true);\n+      expect(result.result.latitude).toBe(123);\n+      expect(result.result.longitude).toBe(456);\n+    });\n \n-    mockGeolocation.getCurrentPosition.mockImplementationOnce(\n-      (_success?: (position: GeolocationResponse) => void, error?: (error: GeolocationError) => void) => {\n-        if (error) {\n-          error(mockError as GeolocationError);\n+    it(\"should show an alert on Android when location permission is denied and showAlert is true\", async () => {\n+      (Geolocation.getCurrentPosition as jest.Mock).mockImplementation(\n+        (_success: any, error?: (error: GeolocationError) => void) => {\n+          if (error) error({ code: 1, message: \"Permission denied\", PERMISSION_DENIED: 1, POSITION_UNAVAILABLE: 2, TIMEOUT: 3 });\n         }\n-      }\n-    );\n-\n-    const result: { success: boolean; error?: GeolocationError; position?: GeolocationResponse } = await new Promise(resolve => {\n-      Geolocation.getCurrentPosition(\n-        (position: GeolocationResponse) => {\n-          resolve({ success: true, position });\n-        },\n-        (error: GeolocationError) => {\n-          resolve({ success: false, error });\n+      );\n+\n+      const result = await LocationHelper.getCurrentPosition(true);\n+\n+      expect(result.success).toBe(false);\n+      expect(result.message).toBe(\"Konum izni verilmemiş.\");\n+      expect(Alert.alert).toHaveBeenCalledWith(\n+        \"\",\n+        \"Konum izni verilmemiş.\",\n+        expect.arrayContaining([\n+          expect.objectContaining({ text: \"İptal\" }),\n+          expect.objectContaining({ text: \"Tamam\" })\n+        ])\n+      );\n+    });\n+\n+    it(\"should show an alert on iOS when location permission is denied and showAlert is true\", async () => {\n+      mockPlatformOS(\"ios\");\n+      jest.resetModules();\n+      const currentHelper = require(\"../../../app/lib/location-helper\");\n+      const currentAlert = require(\"react-native\").Alert;\n+      const currentGeolocation = require(\"@react-native-community/geolocation\").default;\n+\n+      (currentGeolocation.getCurrentPosition as jest.Mock).mockImplementation(\n+        (_success: any, error?: (error: GeolocationError) => void) => {\n+          if (error) error({ code: 1, message: \"Permission denied\", PERMISSION_DENIED: 1, POSITION_UNAVAILABLE: 2, TIMEOUT: 3 });\n         }\n       );\n+\n+      const result = await currentHelper.getCurrentPosition(true);\n+\n+      expect(result.success).toBe(false);\n+      expect(result.message).toBe(\"Konum izni verilmemiş.\");\n+      expect(currentAlert.alert).toHaveBeenCalledWith(\n+        \"\",\n+        \"Konum izni verilmemiş.\",\n+        expect.arrayContaining([\n+          expect.objectContaining({ text: \"İptal\" }),\n+          expect.objectContaining({ text: \"Tamam\" })\n+        ])\n+      );\n     });\n \n-    expect(result.success).toBe(false);\n-    expect(result.error).toEqual({ code: 1, message: \"Location error\" });\n-  });\n+    it(\"should show an alert on Android and call requestEnableLocation when location services are turned off and showAlert is true\", async () => {\n+      mockPlatformOS(\"android\");\n+      jest.resetModules();\n+      const currentHelper = require(\"../../../app/lib/location-helper\");\n+      const currentGeolocation = require(\"@react-native-community/geolocation\").default;\n+      const currentAndroidPermissions = require(\"../../../app/lib/android-permissions\");\n+\n+      (currentGeolocation.getCurrentPosition as jest.Mock).mockImplementation(\n+        (_success: any, error?: (error: GeolocationError) => void) => {\n+          if (error) error({ code: 2, message: \"Position unavailable\", PERMISSION_DENIED: 1, POSITION_UNAVAILABLE: 2, TIMEOUT: 3 });\n+        }\n+      );\n \n-  it(\"should handle timeout errors\", async () => {\n-    const mockGeolocation = Geolocation as jest.Mocked<typeof Geolocation>;\n+      const result = await currentHelper.getCurrentPosition(true);\n+\n+      expect(result.success).toBe(false);\n+      expect(result.message).toBe(\"Konum servisleriniz kapalı.\");\n+      expect(currentAndroidPermissions.requestEnableLocation).toHaveBeenCalledTimes(1);\n+    });\n \n-    const mockError = {\n-      code: 3,\n-      message: \"Timeout error\"\n-    } as any;\n+    it(\"should show an alert on iOS and open settings when location services are turned off and showAlert is true\", async () => {\n+      mockPlatformOS(\"ios\");\n+      jest.resetModules();\n+      const currentHelper = require(\"../../../app/lib/location-helper\");\n+      const currentAlert = require(\"react-native\").Alert;\n+      const currentGeolocation = require(\"@react-native-community/geolocation\").default;\n \n-    mockGeolocation.getCurrentPosition.mockImplementationOnce(\n-      (_success?: (position: GeolocationResponse) => void, error?: (error: GeolocationError) => void, options?: any) => {\n-        if (options?.timeout === 5000 && error) {\n-          error(mockError as GeolocationError);\n+      (currentGeolocation.getCurrentPosition as jest.Mock).mockImplementation(\n+        (_success: any, error?: (error: GeolocationError) => void) => {\n+          if (error) error({ code: 2, message: \"Position unavailable\", PERMISSION_DENIED: 1, POSITION_UNAVAILABLE: 2, TIMEOUT: 3 });\n         }\n-      }\n-    );\n-\n-    const result: { success: boolean; error?: GeolocationError; position?: GeolocationResponse } = await new Promise(resolve => {\n-      Geolocation.getCurrentPosition(\n-        (position: GeolocationResponse) => {\n-          resolve({ success: true, position });\n-        },\n-        (error: GeolocationError) => {\n-          resolve({ success: false, error });\n-        },\n-        { timeout: 5000 }\n       );\n+\n+      const result = await currentHelper.getCurrentPosition(true);\n+\n+      expect(result.success).toBe(false);\n+      expect(result.message).toBe(\"Konum servisleriniz kapalı.\");\n+      expect(currentAlert.alert).toHaveBeenCalledWith(\n+        \"\",\n+        \"Konum servisleriniz kapalı.\",\n+        expect.arrayContaining([\n+          expect.objectContaining({ text: \"İptal\" }),\n+          expect.objectContaining({ text: \"Tamam\" })\n+        ])\n+      );\n+    });\n+\n+    it(\"should not show an alert if showAlert is false in case of an error\", async () => {\n+      (Geolocation.getCurrentPosition as jest.Mock).mockImplementationOnce((success, error) => {\n+        error({ code: LocationHelper.GEOLOCATION_ERROR_CODES.PERMISSION_DENIED });\n+      });\n+\n+      const result = await LocationHelper.getCurrentPosition(false);\n+\n+      expect(result.success).toBe(false);\n+      expect(result.message).toBe(\"\");\n+      expect(Alert.alert).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"should not succeed in case of a timeout error\", async () => {\n+      (Geolocation.getCurrentPosition as jest.Mock).mockImplementationOnce((success, error) => {\n+        error({ code: LocationHelper.GEOLOCATION_ERROR_CODES.TIMEOUT });\n+      });\n+\n+      const result = await LocationHelper.getCurrentPosition();\n+\n+      expect(result.success).toBe(false);\n+      expect(result.message).toBe(\"\");\n+      expect(result.result.latitude).toBeNull();\n+    });\n+\n+    it(\"should invoke cancelCallback with GEOLOCATION_ERROR_CODES.CANCELLED (99) when the cancel button is pressed\", async () => {\n+      mockPlatformOS(\"ios\");\n+      const mockCancelCallback = jest.fn();\n+\n+      jest.resetModules();\n+      const currentHelper = require(\"../../../app/lib/location-helper\");\n+      const currentAlert = require(\"react-native\").Alert;\n+      const currentGeolocation = require(\"@react-native-community/geolocation\").default;\n+\n+      (currentGeolocation.getCurrentPosition as jest.Mock).mockImplementation(\n+        (_success: any, error?: (error: GeolocationError) => void) => {\n+          if (error) error({ code: 2, message: \"Position unavailable\", PERMISSION_DENIED: 1, POSITION_UNAVAILABLE: 2, TIMEOUT: 3 });\n+        }\n+      );\n+\n+      (currentAlert.alert as jest.Mock).mockImplementation((_, __, buttons) => {\n+        const cancelButton = buttons.find((b: any) => b.text === \"İptal\");\n+        if (cancelButton && cancelButton.onPress) {\n+          cancelButton.onPress();\n+        }\n+      });\n+\n+      await currentHelper.getCurrentPosition(true, mockCancelCallback);\n+\n+      expect(mockCancelCallback).toHaveBeenCalledWith(99);\n+    });\n+  });\n+\n+  describe(\"getCityAndDistrictNameByCoordinate\", () => {\n+    const mockCoordinate: UnitCreateLocationModalLocationProps = {\n+      latitude: 39.9334,\n+      longitude: 32.8597,\n+      latitudeDelta: 0.1,\n+      longitudeDelta: 0.1\n+    };\n+    const mockGetStaticText = jest.fn(key => key);\n+\n+    it(\"should return city and district names from administrative_area_level_4 when API response is successful\", async () => {\n+      (global.fetch as jest.Mock).mockResolvedValueOnce({\n+        json: () => Promise.resolve({\n+          status: \"OK\",\n+          results: [{\n+            address_components: [\n+              { long_name: \"Ankara\", types: [\"administrative_area_level_1\"] },\n+              { long_name: \"Çankaya\", types: [\"administrative_area_level_2\"] },\n+              { long_name: \"Kavaklıdere\", types: [\"administrative_area_level_4\"] }\n+            ],\n+            types: [\"administrative_area_level_4\"]\n+          }]\n+        })\n+      });\n+\n+      const result = await LocationHelper.getCityAndDistrictNameByCoordinate(mockCoordinate, mockGetStaticText, mockApiResponseContext);\n+      expect(result).toEqual({\n+        cityName: \"Ankara\",\n+        districtName: \"Çankaya\",\n+        googleResult: expect.any(Object)\n+      });\n+      expect(mockApiResponseContext.setError).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"should return city and district names from administrative_area_level_2 when API response is successful\", async () => {\n+      (global.fetch as jest.Mock).mockResolvedValueOnce({\n+        json: () => Promise.resolve({\n+          status: \"OK\",\n+          results: [{\n+            address_components: [\n+              { long_name: \"Ankara\", types: [\"administrative_area_level_1\"] },\n+              { long_name: \"Çankaya\", types: [\"administrative_area_level_2\"] }\n+            ],\n+            types: [\"administrative_area_level_2\"]\n+          }]\n+        })\n+      });\n+\n+      const result = await LocationHelper.getCityAndDistrictNameByCoordinate(mockCoordinate, mockGetStaticText, mockApiResponseContext);\n+      expect(result).toEqual({\n+        cityName: \"Ankara\",\n+        districtName: \"Çankaya\",\n+        googleResult: expect.any(Object)\n+      });\n+      expect(mockApiResponseContext.setError).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"should return the first result if a specific administrative type is not found\", async () => {\n+      (global.fetch as jest.Mock).mockResolvedValueOnce({\n+        json: () => Promise.resolve({\n+          status: \"OK\",\n+          results: [{\n+            address_components: [\n+              { long_name: \"Ankara\", types: [\"administrative_area_level_1\"] },\n+              { long_name: \"Herhangi Yer\", types: [\"political\"] }\n+            ],\n+            types: [\"political\"]\n+          }]\n+        })\n+      });\n+\n+      const result = await LocationHelper.getCityAndDistrictNameByCoordinate(mockCoordinate, mockGetStaticText, mockApiResponseContext);\n+      expect(result.cityName).toBe(\"Ankara\");\n+      expect(result.districtName).toBeUndefined();\n+      expect(mockApiResponseContext.setError).not.toHaveBeenCalled();\n+    });\n+\n+    it(\"should set an error message and reject if the API returns an error code\", async () => {\n+      mockGetStaticText.mockReturnValue(\"Google Haritalar bağlantı hatası.\");\n+      (global.fetch as jest.Mock).mockResolvedValueOnce({\n+        json: () => Promise.resolve({ status: \"ZERO_RESULTS\", results: [] })\n+      });\n+\n+      await expect(LocationHelper.getCityAndDistrictNameByCoordinate(mockCoordinate, mockGetStaticText, mockApiResponseContext)).rejects.toEqual({\n+        status: \"ZERO_RESULTS\",\n+        results: []\n+      });\n+\n+      expect(mockApiResponseContext.setError).toHaveBeenCalledWith({\n+        show: true,\n+        message: \"Google Haritalar bağlantı hatası.\"\n+      });\n+    });\n+\n+    it(\"should set an error message and reject if a network error occurs during fetch\", async () => {\n+      const mockError = new Error(\"Network error\");\n+      (global.fetch as jest.Mock).mockRejectedValueOnce(mockError);\n+\n+      await expect(LocationHelper.getCityAndDistrictNameByCoordinate(mockCoordinate, mockGetStaticText, mockApiResponseContext)).rejects.toBe(mockError);\n+\n+      expect(mockApiResponseContext.setError).toHaveBeenCalledWith({\n+        show: true,\n+        message: mockError\n+      });\n+    });\n+  });\n+\n+  describe(\"findCityOrDistrictcByName\", () => {\n+    const areaList = [\n+      { id: 1, name: \"Istanbul\" },\n+      { id: 2, name: \"Ankara\" },\n+      { id: 3, name: \"İzmir\" },\n+      { id: 4, name: \"Adana\" }\n+    ];\n+\n+    it(\"should correctly find a name that exists in the list\", () => {\n+      expect(LocationHelper.findCityOrDistrictcByName(areaList, \"Ankara\")).toEqual({ id: 2, name: \"Ankara\" });\n+    });\n+\n+    it(\"should correctly find the name while ignoring Turkish characters\", () => {\n+      expect(LocationHelper.findCityOrDistrictcByName(areaList, \"Izmir\")).toEqual({ id: 3, name: \"İzmir\" });\n+    });\n+\n+    it(\"should be case-insensitive\", () => {\n+      expect(LocationHelper.findCityOrDistrictcByName(areaList, \"istanbul\")).toEqual({ id: 1, name: \"Istanbul\" });\n+    });\n+\n+    it(\"should return undefined if the name is not found in the list\", () => {\n+      expect(LocationHelper.findCityOrDistrictcByName(areaList, \"Bursa\")).toBeUndefined();\n+    });\n+\n+    it(\"should return undefined when the list is empty\", () => {\n+      expect(LocationHelper.findCityOrDistrictcByName([], \"Ankara\")).toBeUndefined();\n+    });\n+  });\n+\n+  describe(\"calculateLatitudeLongitudeAverageAndDelta\", () => {\n+    it(\"should return the correct values for a single coordinate\", () => {\n+      const latitudeList = [40.7128];\n+      const longitudeList = [-74.006];\n+      const result = LocationHelper.calculateLatitudeLongitudeAverageAndDelta(latitudeList, longitudeList);\n+\n+      expect(result.latitude).toBe(40.7128);\n+      expect(result.longitude).toBe(-74.006);\n+      expect(result.latitudeDelta).toBe(0.1);\n+      expect(result.longitudeDelta).toBe(0.1);\n+    });\n+\n+    it(\"should return the correct average and delta values for multiple coordinates\", () => {\n+      const latitudeList = [40.0, 41.0, 42.0];\n+      const longitudeList = [-70.0, -71.0, -72.0];\n+      const result = LocationHelper.calculateLatitudeLongitudeAverageAndDelta(latitudeList, longitudeList);\n+\n+      expect(result.latitude).toBe(41.0);\n+      expect(result.longitude).toBe(-71.0);\n+      expect(result.latitudeDelta).toBe(2.0);\n+      expect(result.longitudeDelta).toBe(2.0);\n+    });\n+\n+    it(\"should return undefined values for an empty list\", () => {\n+      const result = LocationHelper.calculateLatitudeLongitudeAverageAndDelta([], []);\n+      expect(result.latitude).toBeUndefined();\n+      expect(result.longitude).toBeUndefined();\n+      expect(result.latitudeDelta).toBeUndefined();\n+      expect(result.longitudeDelta).toBeUndefined();\n+    });\n+\n+    it(\"should return undefined longitude values when only a list of latitudes is given\", () => {\n+      const latitudeList = [40.0, 41.0];\n+      const result = LocationHelper.calculateLatitudeLongitudeAverageAndDelta(latitudeList);\n+      expect(result.latitude).toBe(40.5);\n+      expect(result.latitudeDelta).toBe(1.0);\n+      expect(result.longitude).toBeUndefined();\n+      expect(result.longitudeDelta).toBeUndefined();\n+    });\n+  });\n+\n+  describe(\"getDestinationsAndWaypoints\", () => {\n+    const mockDestinations = [\n+      { auditId: \"1\", latitude: 40.0, longitude: 30.0 },\n+      { auditId: \"2\", latitude: 41.0, longitude: 31.0 },\n+      { auditId: \"3\", latitude: 42.0, longitude: 32.0 }\n+    ];\n+\n+    it(\"should return the route with the current location and the destinations\", async () => {\n+      (Geolocation.getCurrentPosition as jest.Mock).mockImplementationOnce(success => {\n+        success({ coords: { latitude: 40.5, longitude: 30.5 } });\n+      });\n+      (LocationHelper.getDestinationsAndWaypoints as jest.Mock).mockResolvedValueOnce({\n+        lastDestination: { auditId: \"someId\" },\n+        waypoints: []\n+      });\n+\n+      const result = await LocationHelper.getDestinationsAndWaypoints(mockDestinations);\n+      expect(result).toBeDefined();\n+      expect(result!.lastDestination).toBeDefined();\n+      expect(result!.waypoints).toBeDefined();\n+      expect(result!.waypoints.length).toBeLessThan(mockDestinations.length);\n+    });\n+\n+    it(\"should return undefined if getCurrentPosition fails\", async () => {\n+      (Geolocation.getCurrentPosition as jest.Mock).mockImplementationOnce((success, error) => {\n+        error({ code: LocationHelper.GEOLOCATION_ERROR_CODES.PERMISSION_DENIED });\n+      });\n+\n+      const result = await LocationHelper.getDestinationsAndWaypoints(mockDestinations);\n+      expect(result).toBeUndefined();\n+    });\n+\n+    it(\"should return undefined when the list of destinations is empty\", async () => {\n+      (LocationHelper.getDestinationsAndWaypoints as jest.Mock).mockResolvedValueOnce(undefined);\n+      const result = await LocationHelper.getDestinationsAndWaypoints([]);\n+      expect(result).toBeUndefined();\n     });\n+  });\n \n-    expect(result.success).toBe(false);\n-    expect(result.error).toEqual({ code: 3, message: \"Timeout error\" });\n-  }, 15000);\n-});\n+  describe(\"isMockLocation\", () => {\n+    it(\"should always return false (because it is temporarily disabled)\", async () => {\n+      const result = await LocationHelper.isMockLocation();\n+      expect(result).toBe(false);\n+      expect(isMockingLocation).not.toHaveBeenCalled();\n+      expect(isEmulator).not.toHaveBeenCalled();\n+    });\n+  });\n+\n+  describe(\"checkLocationPermission\", () => {\n+    it(\"should call AndroidPermissions.checkLocationPermission for Android\", async () => {\n+      mockPlatformOS(\"android\");\n+      jest.resetModules();\n+      const currentHelper = require(\"../../../app/lib/location-helper\");\n+      const currentAndroidPermissions = require(\"../../../app/lib/android-permissions\");\n+      (currentAndroidPermissions.checkLocationPermission as jest.Mock).mockResolvedValue(true);\n+\n+      const result = await currentHelper.checkLocationPermission();\n+      expect(result).toBe(true);\n+      expect(currentAndroidPermissions.checkLocationPermission).toHaveBeenCalledTimes(1);\n+    });\n+\n+    it(\"should call IosPermissions.checkLocationPermission for iOS\", async () => {\n+      mockPlatformOS(\"ios\");\n+      jest.resetModules();\n+      const currentHelper = require(\"../../../app/lib/location-helper\");\n+      const currentIosPermissions = require(\"../../../app/lib/ios-permissions\");\n+      (currentIosPermissions.checkLocationPermission as jest.Mock).mockResolvedValue(true);\n+\n+      const result = await currentHelper.checkLocationPermission();\n+      expect(result).toBe(true);\n+      expect(currentIosPermissions.checkLocationPermission).toHaveBeenCalledTimes(1);\n+    });\n+\n+    it(\"should return false if permission is denied on Android\", async () => {\n+      mockPlatformOS(\"android\");\n+      jest.resetModules();\n+      const currentHelper = require(\"../../../app/lib/location-helper\");\n+      const currentAndroidPermissions = require(\"../../../app/lib/android-permissions\");\n+      (currentAndroidPermissions.checkLocationPermission as jest.Mock).mockResolvedValue(false);\n+\n+      const result = await currentHelper.checkLocationPermission();\n+      expect(result).toBe(false);\n+    });\n+\n+    it(\"should return false if permission is denied on iOS\", async () => {\n+      mockPlatformOS(\"ios\");\n+      jest.resetModules();\n+      const currentHelper = require(\"../../../app/lib/location-helper\");\n+      const currentIosPermissions = require(\"../../../app/lib/ios-permissions\");\n+      (currentIosPermissions.checkLocationPermission as jest.Mock).mockResolvedValue(false);\n+\n+      const result = await currentHelper.checkLocationPermission();\n+      expect(result).toBe(false);\n+    });\n+  });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/orientation.test.ts",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/orientation.test.ts",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 58,
          "content": "+import { Dimensions, ScaledSize } from \"react-native\";\n+import { useWindowDimensions } from \"react-native\";\n+\n+import { act, renderHook } from \"@testing-library/react-hooks\";\n+\n+import { ENV } from \"../../../app/config/configurations\";\n+import { useNativeScreenDimensions, useScreenDimensions } from \"../../../app/lib/orientation\";\n+\n+jest.mock(\"react-native\", () => {\n+    const ActualReactNative = jest.requireActual(\"react-native\");\n+    return {\n+        ...ActualReactNative,\n+        Dimensions: {\n+            get: jest.fn().mockReturnValue({ width: 600, height: 400 }),\n+            addEventListener: jest.fn().mockReturnValue({ remove: jest.fn() })\n+        },\n+        useWindowDimensions: jest.fn().mockReturnValue({ width: 600, height: 400, fontScale: 1, scale: 1 })\n+    };\n+});\n+\n+describe(\"useScreenDimensions\", () => {\n+    beforeEach(() => {\n+        (Dimensions.get as jest.Mock).mockClear();\n+        (Dimensions.addEventListener as jest.Mock).mockClear();\n+    });\n+\n+    it(\"should return the correct screen dimensions\", () => {\n+        const { result } = renderHook(() => useScreenDimensions());\n+\n+        expect(Dimensions.get).toHaveBeenCalledWith(\"window\");\n+        expect(result.current.width).toBe(600);\n+        expect(result.current.height).toBe(400);\n+        expect(result.current.diagonal).toBeCloseTo(721.11);\n+        expect(result.current.isLandscape).toBe(true);\n+        expect(result.current.scale).toBe(600 / ENV.deviceWidth);\n+    });\n+\n+    it(\"should add and remove event listener\", () => {\n+        const { unmount } = renderHook(() => useScreenDimensions());\n+        expect(Dimensions.addEventListener).toHaveBeenCalledTimes(1);\n+        unmount();\n+    });\n+});\n+\n+describe(\"useNativeScreenDimensions\", () => {\n+    beforeEach(() => {\n+        (useWindowDimensions as unknown as jest.Mock).mockClear();\n+    });\n+\n+    it(\"should return the correct screen dimensions\", () => {\n+        const { result } = renderHook(() => useNativeScreenDimensions());\n+        expect(result.current.width).toBe(600);\n+        expect(result.current.height).toBe(400);\n+        expect(result.current.diagonal).toBeCloseTo(721.11);\n+        expect(result.current.isLandscape).toBe(true);\n+        expect(result.current.scale).toBe(600 / ENV.deviceWidth);\n+    });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/request-service-helper.test.ts",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/request-service-helper.test.ts",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 215,
          "content": "+describe(\"request-service-helper\", () => {\n+  const checkDynamicFieldRequiredAnswers = jest.fn();\n+  const checkIfAssembleProductHasNoSerialNumber = jest.fn();\n+  const checkIfDisAssembleProductHasNoSerialNumber = jest.fn();\n+  const getPreviousAndNextServiceFormItem = jest.fn();\n+\n+  describe(\"checkIfAssembleProductHasNoSerialNumber\", () => {\n+    it(\"should return false when transferableProducts is null\", () => {\n+      checkIfAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductAssembles: false });\n+      const result = checkIfAssembleProductHasNoSerialNumber(null as any);\n+      expect(result.isSerialNumberNotExistOnProductAssembles).toBe(false);\n+    });\n+\n+    it(\"should return false when requestFlowProductAssembles is null\", () => {\n+      checkIfAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductAssembles: false });\n+      const result = checkIfAssembleProductHasNoSerialNumber({} as any);\n+      expect(result.isSerialNumberNotExistOnProductAssembles).toBe(false);\n+    });\n+\n+    it(\"should return false when requestFlowProductAssembleItems is empty\", () => {\n+      checkIfAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductAssembles: false });\n+      const result = checkIfAssembleProductHasNoSerialNumber({\n+        requestFlowProductAssembles: [{ requestFlowProductAssembleItems: [] }]\n+      } as any);\n+      expect(result.isSerialNumberNotExistOnProductAssembles).toBe(false);\n+    });\n+\n+    it(\"should return true when there is a product assemble with hasSerialNumber true and no serialNumber\", () => {\n+      checkIfAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductAssembles: true, productAssembleName: \"Product1\" });\n+      const result = checkIfAssembleProductHasNoSerialNumber({\n+        requestFlowProductAssembles: [\n+          {\n+            requestFlowProductAssembleItems: [{ hasSerialNumber: true, serialNumber: null, name: \"Product1\" }]\n+          }\n+        ]\n+      } as any);\n+      expect(result.isSerialNumberNotExistOnProductAssembles).toBe(true);\n+      expect(result.productAssembleName).toBe(\"Product1\");\n+    });\n+\n+    it(\"should return false when there is a product assemble with hasSerialNumber true and a serialNumber\", () => {\n+      checkIfAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductAssembles: false });\n+      const result = checkIfAssembleProductHasNoSerialNumber({\n+        requestFlowProductAssembles: [\n+          {\n+            requestFlowProductAssembleItems: [{ hasSerialNumber: true, serialNumber: \"123\" }]\n+          }\n+        ]\n+      } as any);\n+      expect(result.isSerialNumberNotExistOnProductAssembles).toBe(false);\n+    });\n+\n+    it(\"should return false when there is a product assemble with hasSerialNumber false and no serialNumber\", () => {\n+      checkIfAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductAssembles: false });\n+      const result = checkIfAssembleProductHasNoSerialNumber({\n+        requestFlowProductAssembles: [\n+          {\n+            requestFlowProductAssembleItems: [{ hasSerialNumber: false, serialNumber: null }]\n+          }\n+        ]\n+      } as any);\n+      expect(result.isSerialNumberNotExistOnProductAssembles).toBe(false);\n+    });\n+  });\n+\n+  describe(\"checkIfDisAssembleProductHasNoSerialNumber\", () => {\n+    it(\"should return false when transferableProducts is null\", () => {\n+      checkIfDisAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductDisAssembles: false });\n+      const result = checkIfDisAssembleProductHasNoSerialNumber(null as any);\n+      expect(result.isSerialNumberNotExistOnProductDisAssembles).toBe(false);\n+    });\n+\n+    it(\"should return false when requestFlowProductDisAssembles is null\", () => {\n+      checkIfDisAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductDisAssembles: false });\n+      const result = checkIfDisAssembleProductHasNoSerialNumber({} as any);\n+      expect(result.isSerialNumberNotExistOnProductDisAssembles).toBe(false);\n+    });\n+\n+    it(\"should return false when requestFlowProductAssembleItems is empty\", () => {\n+      checkIfDisAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductDisAssembles: false });\n+      const result = checkIfDisAssembleProductHasNoSerialNumber({\n+        requestFlowProductDisAssembles: [{ requestFlowProductAssembleItems: [] }]\n+      } as any);\n+      expect(result.isSerialNumberNotExistOnProductDisAssembles).toBe(false);\n+    });\n+\n+    it(\"should return true when there is a product dis-assemble with hasSerialNumber true and no serialNumber\", () => {\n+      checkIfDisAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductDisAssembles: true, productDisAssembleName: \"Product1\" });\n+      const result = checkIfDisAssembleProductHasNoSerialNumber({\n+        requestFlowProductDisAssembles: [\n+          {\n+            requestFlowProductAssembleItems: [{ hasSerialNumber: true, serialNumber: null, name: \"Product1\" }]\n+          }\n+        ]\n+      } as any);\n+      expect(result.isSerialNumberNotExistOnProductDisAssembles).toBe(true);\n+      expect(result.productDisAssembleName).toBe(\"Product1\");\n+    });\n+\n+    it(\"should return false when there is a product dis-assemble with hasSerialNumber true and a serialNumber\", () => {\n+      checkIfDisAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductDisAssembles: false });\n+      const result = checkIfDisAssembleProductHasNoSerialNumber({\n+        requestFlowProductDisAssembles: [\n+          {\n+            requestFlowProductAssembleItems: [{ hasSerialNumber: true, serialNumber: \"123\" }]\n+          }\n+        ]\n+      } as any);\n+      expect(result.isSerialNumberNotExistOnProductDisAssembles).toBe(false);\n+    });\n+\n+    it(\"should return false when there is a product dis-assemble with hasSerialNumber false and no serialNumber\", () => {\n+      checkIfDisAssembleProductHasNoSerialNumber.mockReturnValue({ isSerialNumberNotExistOnProductDisAssembles: false });\n+      const result = checkIfDisAssembleProductHasNoSerialNumber({\n+        requestFlowProductDisAssembles: [\n+          {\n+            requestFlowProductAssembleItems: [{ hasSerialNumber: false, serialNumber: null }]\n+          }\n+        ]\n+      } as any);\n+      expect(result.isSerialNumberNotExistOnProductDisAssembles).toBe(false);\n+    });\n+  });\n+\n+  describe(\"getPreviousAndNextServiceFormItem\", () => {\n+    it(\"should return null previousServiceItem and nextServiceFormItem when allServiceFormItems is null\", () => {\n+      getPreviousAndNextServiceFormItem.mockReturnValue({ previousServiceItem: null, nextServiceFormItem: null });\n+      const result = getPreviousAndNextServiceFormItem(null as any, {} as any);\n+      expect(result.previousServiceItem).toBe(null);\n+      expect(result.nextServiceFormItem).toBe(null);\n+    });\n+\n+    it(\"should return null previousServiceItem and nextServiceFormItem when allServiceFormItems is empty\", () => {\n+      getPreviousAndNextServiceFormItem.mockReturnValue({ previousServiceItem: null, nextServiceFormItem: null });\n+      const result = getPreviousAndNextServiceFormItem([], {} as any);\n+      expect(result.previousServiceItem).toBe(null);\n+      expect(result.nextServiceFormItem).toBe(null);\n+    });\n+\n+    it(\"should return null previousServiceItem when processingServiceFormItem is the first element\", () => {\n+      getPreviousAndNextServiceFormItem.mockReturnValue({ previousServiceItem: null, nextServiceFormItem: { itemId: \"2\" } });\n+      const allServiceFormItems = [{ itemId: \"1\" }, { itemId: \"2\" }];\n+      const processingServiceFormItem = { itemId: \"1\" };\n+      const result = getPreviousAndNextServiceFormItem(allServiceFormItems as any, processingServiceFormItem as any);\n+      expect(result.previousServiceItem).toBe(null);\n+      expect(result.nextServiceFormItem).toEqual({ itemId: \"2\" });\n+    });\n+\n+    it(\"should return null nextServiceFormItem when processingServiceFormItem is the last element\", () => {\n+      getPreviousAndNextServiceFormItem.mockReturnValue({ previousServiceItem: { itemId: \"1\" }, nextServiceFormItem: null });\n+      const allServiceFormItems = [{ itemId: \"1\" }, { itemId: \"2\" }];\n+      const processingServiceFormItem = { itemId: \"2\" };\n+      const result = getPreviousAndNextServiceFormItem(allServiceFormItems as any, processingServiceFormItem as any);\n+      expect(result.previousServiceItem).toEqual({ itemId: \"1\" });\n+      expect(result.nextServiceFormItem).toBe(null);\n+    });\n+\n+    it(\"should return previous and next service form items when processingServiceFormItem is in the middle\", () => {\n+      getPreviousAndNextServiceFormItem.mockReturnValue({ previousServiceItem: { itemId: \"1\" }, nextServiceFormItem: { itemId: \"3\" } });\n+      const allServiceFormItems = [{ itemId: \"1\" }, { itemId: \"2\" }, { itemId: \"3\" }];\n+      const processingServiceFormItem = { itemId: \"2\" };\n+      const result = getPreviousAndNextServiceFormItem(allServiceFormItems as any, processingServiceFormItem as any);\n+      expect(result.previousServiceItem).toEqual({ itemId: \"1\" });\n+      expect(result.nextServiceFormItem).toEqual({ itemId: \"3\" });\n+    });\n+  });\n+\n+  describe(\"checkDynamicFieldRequiredAnswers\", () => {\n+    it(\"should return success true when dynamicFields is empty\", () => {\n+      checkDynamicFieldRequiredAnswers.mockReturnValue({ success: true, field: null });\n+      const result = checkDynamicFieldRequiredAnswers([], {});\n+      expect(result.success).toBe(true);\n+      expect(result.field).toBe(null);\n+    });\n+\n+    it(\"should return success true when there are no required dynamic fields\", () => {\n+      checkDynamicFieldRequiredAnswers.mockReturnValue({ success: true, field: null });\n+      const dynamicFields = [{ title: \"Field1\", isRequired: false }];\n+      const answers = { Field1: \"Answer1\" };\n+      const result = checkDynamicFieldRequiredAnswers(dynamicFields as any, answers);\n+      expect(result.success).toBe(true);\n+      expect(result.field).toBe(null);\n+    });\n+\n+    it(\"should return success true when all required dynamic fields have answers\", () => {\n+      checkDynamicFieldRequiredAnswers.mockReturnValue({ success: true, field: null });\n+      const dynamicFields = [{ title: \"Field1\", isRequired: true }];\n+      const answers = { Field1: \"Answer1\" };\n+      const result = checkDynamicFieldRequiredAnswers(dynamicFields as any, answers);\n+      expect(result.success).toBe(true);\n+      expect(result.field).toBe(null);\n+    });\n+\n+    it(\"should return success false when a required dynamic field is missing an answer\", () => {\n+      checkDynamicFieldRequiredAnswers.mockReturnValue({ success: false, field: { title: \"Field1\", isRequired: true } });\n+      const dynamicFields = [{ title: \"Field1\", isRequired: true }];\n+      const answers = {};\n+      const result = checkDynamicFieldRequiredAnswers(dynamicFields as any, answers);\n+      expect(result.success).toBe(false);\n+      expect(result.field).toEqual({ title: \"Field1\", isRequired: true });\n+    });\n+\n+    it(\"should return success false when multiple required dynamic fields are missing answers\", () => {\n+      checkDynamicFieldRequiredAnswers.mockReturnValue({ success: false, field: { title: \"Field1\", isRequired: true } });\n+      const dynamicFields = [\n+        { title: \"Field1\", isRequired: true },\n+        { title: \"Field2\", isRequired: true }\n+      ];\n+      const answers = {};\n+      const result = checkDynamicFieldRequiredAnswers(dynamicFields as any, answers);\n+      expect(result.success).toBe(false);\n+      expect(result.field).toEqual({ title: \"Field1\", isRequired: true });\n+    });\n+  });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/print-provider.test.ts",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/print-provider.test.ts",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 132,
          "content": "+import RNHTMLtoPDF from \"react-native-html-to-pdf\";\n+import RNPrint from \"react-native-print\";\n+\n+import { printHtml, printPdf } from \"../../../app/lib/print-provider\";\n+\n+jest.mock(\"react-native-print\", () => ({\n+    print: jest.fn().mockImplementation(() => Promise.resolve(true))\n+}));\n+\n+jest.mock(\"../../../app/lib/task-file-helper\", () => ({\n+    removeTempPDFFilesAfterPrint: jest.fn()\n+}));\n+\n+describe(\"print-provider\", () => {\n+    afterEach(() => {\n+        jest.clearAllMocks();\n+    });\n+\n+    describe(\"printHtml\", () => {\n+        it(\"should print HTML content successfully\", async () => {\n+            const htmlContent = \"<p>Test HTML Content</p>\";\n+            const filePath = \"test-file-path\";\n+            RNHTMLtoPDF.convert = jest.fn().mockResolvedValue({ filePath: \"mockedFilePath\" });\n+            (RNPrint.print as jest.Mock).mockResolvedValue(true);\n+\n+            const result = await printHtml(htmlContent);\n+\n+            expect(RNHTMLtoPDF.convert).toHaveBeenCalledWith({\n+                html: htmlContent,\n+                fileName: expect.any(String)\n+            });\n+            expect(RNPrint.print).toHaveBeenCalledWith({\n+                filePath: \"mockedFilePath\"\n+            });\n+            expect(result).toBe(true);\n+        });\n+\n+        it(\"should handle PDF conversion error\", async () => {\n+            const htmlContent = \"<p>Test HTML Content</p>\";\n+            RNHTMLtoPDF.convert = jest.fn().mockRejectedValue(new Error(\"PDF conversion failed\"));\n+\n+            const result = await printHtml(htmlContent);\n+\n+            expect(RNHTMLtoPDF.convert).toHaveBeenCalledWith({\n+                html: htmlContent,\n+                fileName: expect.any(String)\n+            });\n+            expect(RNPrint.print).not.toHaveBeenCalled();\n+            expect(result).toBe(null);\n+        });\n+\n+        it(\"should handle printing error\", async () => {\n+            const htmlContent = \"<p>Test HTML Content</p>\";\n+            const filePath = \"test-file-path\";\n+            RNHTMLtoPDF.convert = jest.fn().mockResolvedValue({ filePath: \"mockedFilePath\" });\n+            (RNPrint.print as jest.Mock).mockRejectedValue(new Error(\"Printing failed\"));\n+\n+            const result = await printHtml(htmlContent);\n+\n+            expect(RNHTMLtoPDF.convert).toHaveBeenCalledWith({\n+                html: htmlContent,\n+                fileName: expect.any(String)\n+            });\n+            expect(RNPrint.print).toHaveBeenCalledWith({\n+                filePath: \"mockedFilePath\"\n+            });\n+            expect(result).toBe(null);\n+        });\n+\n+        it(\"should execute callback function\", async () => {\n+            const htmlContent = \"<p>Test HTML Content</p>\";\n+            const filePath = \"test-file-path\";\n+            RNHTMLtoPDF.convert = jest.fn().mockResolvedValue({ filePath: \"mockedFilePath\" });\n+            (RNPrint.print as jest.Mock).mockResolvedValue(true);\n+            const callback = jest.fn();\n+\n+            await printHtml(htmlContent, callback);\n+\n+            expect(callback).toHaveBeenCalled();\n+        });\n+    });\n+\n+    describe(\"printPdf\", () => {\n+        it(\"should print PDF successfully\", async () => {\n+            const filePath = \"test-file-path.pdf\";\n+            (RNPrint.print as jest.Mock).mockResolvedValue(true);\n+            const successCallback = jest.fn();\n+            const errorCallback = jest.fn();\n+\n+            const result = await printPdf(filePath, successCallback, errorCallback);\n+\n+            expect(RNPrint.print).toHaveBeenCalledWith({ filePath });\n+            expect(result).toBe(true);\n+            expect(successCallback).toHaveBeenCalledWith(true);\n+            expect(errorCallback).not.toHaveBeenCalled();\n+        });\n+\n+        it(\"should handle printing error\", async () => {\n+            const filePath = \"test-file-path.pdf\";\n+            (RNPrint.print as jest.Mock).mockRejectedValue(new Error(\"Printing failed\"));\n+            const successCallback = jest.fn();\n+            const errorCallback = jest.fn();\n+\n+            const result = await printPdf(filePath, successCallback, errorCallback);\n+\n+            expect(RNPrint.print).toHaveBeenCalledWith({ filePath });\n+            expect(result).toBe(null);\n+            expect(successCallback).not.toHaveBeenCalled();\n+            expect(errorCallback).toHaveBeenCalledWith(new Error(\"Printing failed\"));\n+        });\n+\n+        it(\"should call successCallback if provided\", async () => {\n+            const filePath = \"test-file-path.pdf\";\n+            (RNPrint.print as jest.Mock).mockResolvedValue(true);\n+            const successCallback = jest.fn();\n+\n+            await printPdf(filePath, successCallback);\n+\n+            expect(successCallback).toHaveBeenCalledWith(true);\n+        });\n+\n+        it(\"should call errorCallback if provided\", async () => {\n+            const filePath = \"test-file-path.pdf\";\n+            (RNPrint.print as jest.Mock).mockRejectedValue(new Error(\"Printing failed\"));\n+            const errorCallback = jest.fn();\n+\n+            await printPdf(filePath, undefined, errorCallback);\n+\n+            expect(errorCallback).toHaveBeenCalledWith(new Error(\"Printing failed\"));\n+        });\n+    });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/regex-validate-operation.test.ts",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/regex-validate-operation.test.ts",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 51,
          "content": "+import { getHost, validateEmail, validateGSMNo } from \"../../../app/lib/regex-validate-operation\";\n+\n+jest.mock(\"../../../app/config/configurations\", () => ({\n+    ENV: {\n+        EMAIL_REGEX:\n+            /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/,\n+        PHONE_REGEX: /^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/,\n+        HOST_REGEX: /^(?:https?:\\/\\/)([^\\/]+)([^\\?]*)\\??(.*)$/\n+    }\n+}));\n+\n+describe(\"regex-validate-operation\", () => {\n+    const { ENV } = require(\"../../../app/config/configurations\");\n+\n+    describe(\"validateEmail\", () => {\n+        it(\"should return true for valid email addresses\", () => {\n+            expect(validateEmail(\"test@example.com\")).toBe(true);\n+            expect(validateEmail(\"test.test@example.com\")).toBe(true);\n+        });\n+\n+        it(\"should return false for invalid email addresses\", () => {\n+            expect(validateEmail(\"test@example\")).toBe(false);\n+            expect(validateEmail(\"testexample.com\")).toBe(false);\n+        });\n+    });\n+\n+    describe(\"validateGSMNo\", () => {\n+        it(\"should return true for valid GSM numbers\", () => {\n+            expect(ENV.PHONE_REGEX.test(\"+905551234567\")).toBe(true);\n+            expect(ENV.PHONE_REGEX.test(\"05551234567\")).toBe(true);\n+            expect(ENV.PHONE_REGEX.test(\"5551234567\")).toBe(true);\n+        });\n+\n+        it(\"should return false for invalid GSM numbers\", () => {\n+            expect(ENV.PHONE_REGEX.test(\"123\")).toBe(false);\n+            expect(ENV.PHONE_REGEX.test(\"abc\")).toBe(false);\n+        });\n+    });\n+\n+    describe(\"getHost\", () => {\n+        it(\"should return the host for valid URLs\", () => {\n+            const result = getHost(\"https://www.example.com\");\n+            expect(result ? result[1] : null).toBe(\"www.example.com\");\n+        });\n+\n+        it(\"should return null for invalid URLs\", () => {\n+            const result = getHost(\"invalid-url\");\n+            expect(result).toBe(null);\n+        });\n+    });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/regex-validate-operation.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/regex-validate-operation.ts",
          "changeType": "add",
          "oldLineStart": 1,
          "oldLineCount": 15,
          "newLineStart": 1,
          "newLineCount": 36,
          "content": " import { ENV } from \"../config/configurations\";\n \n+/**\n+ * Girilen metnin geçerli bir GSM (cep telefonu) numarası olup olmadığını kontrol eder.\n+ *\n+ * @param {string} text - Doğrulanmak istenen telefon numarası.\n+ * @returns {boolean} Geçerli bir GSM numarasıysa `true`, değilse `false` döner.\n+ *\n+ */\n function validateGSMNo(text: string): boolean {\n   const re = ENV.PHONE_REGEX2;\n   return re.test(String(text).toLowerCase());\n }\n \n+/**\n+ * Girilen metnin geçerli bir e-posta adresi olup olmadığını kontrol eder.\n+ *\n+ * @param {string} text - Doğrulanmak istenen e-posta adresi.\n+ * @returns {boolean} Geçerli bir e-posta adresiyse `true`, değilse `false` döner.\n+ *\n+ */\n function validateEmail(text: string): boolean {\n   const re = ENV.EMAIL_REGEX;\n   return re.test(String(text).toLowerCase());\n }\n \n+/**\n+ * Verilen URL içinden host bilgisini düzenli ifade kullanarak ayıklar.\n+ *\n+ * @param {string} url - Host bilgisi alınmak istenen URL.\n+ * @returns {RegExpExecArray | null} Eşleşme bulunduysa `RegExpExecArray`, bulunamadıysa `null` döner.\n+ *\n+ */\n function getHost(url: string): RegExpExecArray | null {\n   return ENV.HOST_REGEX.exec(url);\n }",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/orientation.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/orientation.ts",
          "changeType": "add",
          "oldLineStart": 4,
          "oldLineCount": 6,
          "newLineStart": 4,
          "newLineCount": 22,
          "content": " import { ENV } from \"../config/configurations\";\n \n /** @deprecated use the useNativeScreenDimensions */\n+\n+/**\n+ * Ekran boyutlarını, yönünü (dikey/yatay), çapraz (diagonal) uzunluğu ve ölçek bilgisini dönen özel bir React Hook.\n+ * \n+ * Bu hook ekran boyutu değiştiğinde (örneğin cihaz döndüğünde) otomatik olarak yeniden hesaplama yapar.\n+ *\n+ * @returns {{\n+*   width: number;\n+*   height: number;\n+*   scale: number;\n+*   fontScale: number;\n+*   diagonal: number;\n+*   isLandscape: boolean;\n+* }} Güncel ekran boyutu verileri.\n+*\n+*/\n const useScreenDimensions = () => {\n   const [screenData, setScreenData] = useState(Dimensions.get(\"window\"));\n ",
          "context": "import { Dimensions, ScaledSize, useWindowDimensions } from \"react-native\";"
        },
        {
          "filePath": "/app/lib/orientation.ts",
          "changeType": "add",
          "oldLineStart": 30,
          "oldLineCount": 6,
          "newLineStart": 46,
          "newLineCount": 22,
          "content": "   return data;\n };\n \n+/**\n+ * `useWindowDimensions` hook'unu kullanarak ekran boyutları, yönü, çapraz uzunluğu ve ölçek bilgilerini döner.\n+ * \n+ * Bu hook sistemden otomatik olarak güncel ekran boyutlarını alır ve yeniden render durumunda değerler otomatik güncellenir.\n+ * Özellikle responsive tasarımlar için faydalıdır.\n+ *\n+ * @returns {{\n+*   width: number;\n+*   height: number;\n+*   scale: number;\n+*   fontScale: number;\n+*   diagonal: number;\n+*   isLandscape: boolean;\n+* }} Güncel ekran ölçü ve ölçek bilgileri.\n+*\n+*/\n const useNativeScreenDimensions = () => {\n   const screenData = useWindowDimensions();\n ",
          "context": "const useScreenDimensions = () => {"
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/responsive.test.ts",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/responsive.test.ts",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 65,
          "content": "+import { ENV } from \"../../../app/config/configurations\";\n+import { diagonalPercentageToDP, heightPercentageToDP, widthPercentageToDP } from \"../../../app/lib/responsive\";\n+\n+describe(\"Responsive Functions\", () => {\n+  const originalENV = { ...ENV };\n+\n+  afterEach(() => {\n+    // Restore original ENV after each test\n+    Object.assign(ENV, originalENV);\n+  });\n+\n+  it(\"widthPercentageToDP should return correct value\", () => {\n+    ENV.deviceWidth = 768;\n+    expect(widthPercentageToDP(\"50%\")).toBe(384);\n+    expect(widthPercentageToDP(\"25%\")).toBe(192);\n+  });\n+\n+  it(\"widthPercentageToDP should return undefined when percentage is undefined\", () => {\n+    ENV.deviceWidth = 768;\n+    expect(widthPercentageToDP(undefined)).toBeUndefined();\n+  });\n+\n+  it(\"widthPercentageToDP should return undefined when screenWidth is undefined\", () => {\n+    const originalDeviceWidth = ENV.deviceWidth;\n+    (ENV as any).deviceWidth = undefined;\n+    expect(widthPercentageToDP(\"50%\")).toBeUndefined();\n+    ENV.deviceWidth = originalDeviceWidth; // Restore original value\n+  });\n+\n+  it(\"heightPercentageToDP should return correct value\", () => {\n+    ENV.deviceHeight = 1024;\n+    expect(heightPercentageToDP(\"50%\")).toBe(512);\n+    expect(heightPercentageToDP(\"25%\")).toBe(256);\n+  });\n+\n+  it(\"heightPercentageToDP should return undefined when percentage is undefined\", () => {\n+    ENV.deviceHeight = 1024;\n+    expect(heightPercentageToDP(undefined)).toBeUndefined();\n+  });\n+\n+  it(\"heightPercentageToDP should return undefined when screenHeight is undefined\", () => {\n+    const originalDeviceHeight = ENV.deviceHeight;\n+    (ENV as any).deviceHeight = undefined;\n+    expect(heightPercentageToDP(\"50%\")).toBeUndefined();\n+    ENV.deviceHeight = originalDeviceHeight; // Restore original value\n+  });\n+\n+  it(\"diagonalPercentageToDP should return correct value\", () => {\n+    ENV.diagonalScreenSize = 1280;\n+    expect(diagonalPercentageToDP(\"50%\")).toBe(640);\n+    expect(diagonalPercentageToDP(\"25%\")).toBe(320);\n+  });\n+\n+  it(\"diagonalPercentageToDP should return undefined when percentage is undefined\", () => {\n+    ENV.diagonalScreenSize = 1280;\n+    expect(diagonalPercentageToDP(undefined)).toBeUndefined();\n+  });\n+\n+  it(\"diagonalPercentageToDP should return undefined when screenDiagonal is undefined\", () => {\n+    const originalDiagonalScreenSize = ENV.diagonalScreenSize;\n+    (ENV as any).diagonalScreenSize = undefined;\n+    expect(diagonalPercentageToDP(\"50%\")).toBeUndefined();\n+    ENV.diagonalScreenSize = originalDiagonalScreenSize; // Restore original value\n+  });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/sentry/SentryMobile.test.ts",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/sentry/SentryMobile.test.ts",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 373,
          "content": "+import * as Sentry from \"@sentry/react-native\";\n+\n+import { HttpClient as HttpClientIntegration } from \"@sentry/integrations\";\n+\n+import { ENV } from \"../../../../app/config/configurations\";\n+import { APP_JSON } from \"../../../../app/config/customer-config\";\n+import { getHost } from \"../../../../app/lib/regex-validate-operation\";\n+import { SentryMobile } from \"../../../../app/lib/sentry/SentryMobile\";\n+import { AuthSliceInitialState } from \"../../../../app/store/slices/auth.slice\";\n+import { AuthUserFlowAccountWithAccount } from \"../../../../app/types/responses/AuthUserFlowAccount\";\n+import { Enviroment } from \"../../../../app/types/responses/Enviroment\";\n+import { GetCitiesResponse } from \"../../../../app/types/responses/GetCitiesResponse\";\n+import { GetUsersFromUserGroupResponse } from \"../../../../app/types/responses/GetUsersFromUserGroupResponse\";\n+\n+jest.mock(\"lib/regex-validate-operation\", () => ({\n+  getHost: jest.fn((url: string) => {\n+    if (url) return [\"https://test.example.com\", \"test.example.com\"];\n+    return null;\n+  })\n+}));\n+\n+jest.mock(\"config/configurations\");\n+\n+jest.mock(\"config/customer-config\", () => ({\n+  APP_JSON: {\n+    name: \"LenaFieldRN\",\n+    displayName: \"Field\",\n+    version: \"5.0.0\",\n+    environment: \"Test_Prod\",\n+    codepushVersion: 1,\n+    iosVersion: \"13.5.0\",\n+    versionCode: 1,\n+    androidVersionCode: 53,\n+    iosVersionCode: 56,\n+    SELECTED_COMPANY_OPTION: \"01\",\n+    branch: { main: \"version/v4.12\" },\n+    defaultSchemes: [\"fieldApp\", \"flowApp\"],\n+    associatedDomains: [\n+      \"testomp.lena.solutions\",\n+      \"omptest.opet.com.tr\",\n+      \"audit.lena.solutions\",\n+      \"omp.opet.com.tr\",\n+      \"ipragazsatis.lena.solutions\",\n+      \"ipragazsap.lena.solutions\",\n+      \"direktsatis.ipragaz.com.tr\",\n+      \"teknikdestek.ipragaz.com.tr\",\n+      \"lenateknikdestek.ipragaz.com.tr\",\n+      \"oyak.lena.solutions\",\n+      \"geosfield.oyakpetrol.com.tr\",\n+      \"field.lena.solutions\",\n+      \"192.168.1.102\",\n+      \"fieldpreprod.lena.solutions\",\n+      \"turpak.lena.solutions\",\n+      \"fieldpoc.lenasoftware.com\",\n+      \"fielddemo.lenasoftware.com\",\n+      \"ofield.lenasoftware.com\",\n+      \"field.lenasoftware.com\",\n+      \"falcon.lenasoftware.com\",\n+      \"falcon-test.lenasoftware.com\",\n+      \"field.turpak.com.tr\",\n+      \"atostalep.com\",\n+      \"flow.lena.solutions\",\n+      \"be32-185-81-238-2.ngrok-free.app\",\n+      \"kocwave.lena.solutions\",\n+      \"catiteknoloji.lena.solutions\",\n+      \"sahakontroltest.aydemperakende.com.tr\",\n+      \"sahakontrol.aydemperakende.com.tr\",\n+      \"fusiontest.turpak.com.tr\",\n+      \"shellmuhendisliksaha.atostalep.com\",\n+      \"699e-185-81-238-2.ngrok-free.app\",\n+      \"699e-185-81-238-2.ngrok-free.app\",\n+      \"odeabank.lenasoftware.com\",\n+      \"sys.utts.net.tr\",\n+      \"sys.utts.gov.tr\",\n+      \"automation-field.lena.solutions\",\n+      \"release-field.lena.solutions\",\n+      \"automation-field.lena.solutions\",\n+      \"automation-field.lena.solutions\",\n+      \"release-field.lena.solutions\",\n+      \"automation-field.lena.solutions\",\n+      \"shell-merge.lena.solutions\",\n+      \"shell-old.lena.solutions\",\n+      \"ipragaztuplu.lena.solutions\",\n+      \"sahadenetim.opetcloud.net\",\n+      \"sahadenetim-test.opetcloud.net\",\n+      \"*.lena.solutions\",\n+      \"*.opet.com.tr\",\n+      \"*.ipragaz.com.tr\",\n+      \"*.oyakpetrol.com.tr\",\n+      \"*.lenasoftware.com\",\n+      \"*.turpak.com.tr\",\n+      \"*.atostalep.com\",\n+      \"*.ngrok-free.app\",\n+      \"*.aydemperakende.com.tr\",\n+      \"*.utts.net.tr\",\n+      \"*.utts.gov.tr\",\n+      \"*.opetcloud.net\"\n+    ]\n+  }\n+}));\n+\n+jest.mock(\"@sentry/react-native\", () => {\n+  return {\n+    init: jest.fn(),\n+    ReactNavigationInstrumentation: jest.fn(),\n+    ReactNativeTracing: function (options: any) {\n+      (this as any)._options = options;\n+    }\n+  };\n+});\n+\n+jest.mock(\"@sentry/integrations\", () => {\n+  return {\n+    HttpClient: function (options: any) {\n+      (this as any).options = options;\n+    }\n+  } as any;\n+});\n+\n+enum AuthTypes {\n+  Form = \"form\",\n+  SSO = \"sso\"\n+}\n+\n+const mockAuthUserAccount = {\n+  userId: 123,\n+  email: \"test@example.com\",\n+  username: \"testuser\",\n+  firstName: \"Test\",\n+  lastName: \"User\",\n+  phone: \"+1234567890\",\n+  isActive: true,\n+  isDeleted: false,\n+  createdDate: \"2023-01-01T00:00:00Z\",\n+  lastLoginDate: \"2023-06-01T00:00:00Z\",\n+  userLogo: \"logo.png\",\n+  userLogoUrl: \"https://example.com/logo.png\",\n+  name: \"Test\",\n+  lastname: \"User\",\n+  department: \"IT\",\n+  position: \"Developer\",\n+  language: \"en\",\n+  timezone: \"UTC+3\",\n+  permissions: [\n+    {\n+      name: \"test-permission\" as \"string\",\n+      authorizedScenarios: [\n+        {\n+          authorizedScenario: 1,\n+          authorizedLocationIds: [101, 102],\n+          authorizedRegionIds: [201, 202],\n+          isAuthorizedAllRegions: false\n+        }\n+      ]\n+    }\n+  ]\n+};\n+\n+const mockAuthUserFlowAccount: AuthUserFlowAccountWithAccount = {\n+  account: mockAuthUserAccount,\n+  applicationPublicServer: \"public-server\",\n+  applicationCode: \"APP123\",\n+  accessToken: \"access-token\",\n+  refreshToken: \"refresh-token\",\n+  expiration: \"2023-01-01T00:00:00Z\"\n+};\n+\n+const mockCities: GetCitiesResponse[] = [\n+  { cityId: 1, name: \"Istanbul\" },\n+  { cityId: 2, name: \"Ankara\" }\n+];\n+\n+const mockUsersFromUserGroup: GetUsersFromUserGroupResponse[] = [\n+  {\n+    userGroupName: \"Admin Group\",\n+    locationCode: \"LOC001\",\n+    userGroupId: 1,\n+    userId: 1,\n+    fullname: \"User One\",\n+    passwordCreateDate: \"2023-01-01\",\n+    userLogo: \"user1.png\",\n+    name: \"User\",\n+    lastname: \"One\",\n+    email: \"user1@example.com\",\n+    phone: \"+1234567890\"\n+  },\n+  {\n+    userGroupName: \"User Group\",\n+    locationCode: \"LOC002\",\n+    userGroupId: 2,\n+    userId: 2,\n+    fullname: \"User Two\",\n+    passwordCreateDate: \"2023-01-02\",\n+    userLogo: \"user2.png\",\n+    name: \"User\",\n+    lastname: \"Two\",\n+    email: \"user2@example.com\",\n+    phone: \"+1234567891\"\n+  }\n+];\n+\n+const mockUserInformation: AuthSliceInitialState = {\n+  jwtToken: \"mock-jwt-token\",\n+  tokenOffset: \"mock-offset\",\n+  account: mockAuthUserAccount,\n+  lockSecond: 0,\n+  isLocked: false,\n+  twoFactor: true,\n+  twoFactorTime: 1234567890,\n+  locationId: 1,\n+  locationCode: \"LOC001\",\n+  isPasswordExpired: false,\n+  isRequestPermitted: true,\n+  userOrderPermission: {\n+    canOrder: true,\n+    canTransfer: false,\n+    addProduct: true\n+  },\n+  externalApps: {\n+    CRM: true,\n+    ERP: false\n+  },\n+  companyId: 1,\n+  sourceUserId: null,\n+  flow: mockAuthUserFlowAccount,\n+  initialized: true,\n+  isAuthenticated: true,\n+  appDownloadUrl: null,\n+  appVersion: null,\n+  passwordExpired: false,\n+  startedTasksExist: false,\n+  changePassword: false,\n+  isWorkPlanCreateRequired: false,\n+  unReadNotificationCount: 0,\n+  cities: mockCities,\n+  userPermissions: [1, 2, 3],\n+  usersFromUserGroup: mockUsersFromUserGroup\n+};\n+\n+const mockEnv: Enviroment = {\n+  name: \"test-environment\",\n+  url: \"https://test.example.com\",\n+  isFlow: false,\n+  isOfflineModeEnable: true,\n+  authTypes: [AuthTypes.Form],\n+  sslConfig: {\n+    enabled: true,\n+    host: \"testhost\",\n+    port: 443\n+  }\n+};\n+\n+beforeEach(() => {\n+  jest.clearAllMocks();\n+  (Sentry.init as jest.Mock).mockReset();\n+});\n+\n+describe(\"SentryMobile\", () => {\n+  describe(\"init\", () => {\n+    it(\"should initialize Sentry with correct configuration\", async () => {\n+      await SentryMobile.init(mockUserInformation, mockEnv);\n+\n+      expect(Sentry.init).toHaveBeenCalledWith({\n+        dsn: ENV.SENTRY_DSN,\n+        tracesSampleRate: 0.2,\n+        enableAppHangTracking: false,\n+        tracesSampler: expect.any(Function),\n+        attachScreenshot: true,\n+        beforeSend: expect.any(Function),\n+        integrations: expect.arrayContaining([expect.any(Sentry.ReactNativeTracing), expect.any(HttpClientIntegration)])\n+      });\n+    });\n+\n+    it(\"should set user information in beforeSend\", async () => {\n+      await SentryMobile.init(mockUserInformation, mockEnv);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const testEvent = {};\n+      const processedEvent = initCall.beforeSend(testEvent);\n+\n+      expect(processedEvent.user).toEqual({\n+        ...mockUserInformation.account,\n+        email: mockUserInformation.account?.email,\n+        id: mockUserInformation.account?.userId,\n+        username: mockUserInformation.account?.username\n+      });\n+      expect(processedEvent).toBeDefined();\n+    });\n+\n+    it(\"should include appJSON and env in extra data\", async () => {\n+      await SentryMobile.init(mockUserInformation, mockEnv);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const testEvent = {};\n+      const processedEvent = initCall.beforeSend(testEvent);\n+\n+      expect(processedEvent.extra).toEqual({\n+        appJSON: JSON.stringify(APP_JSON),\n+        env: JSON.stringify(mockEnv)\n+      });\n+    });\n+\n+    it(\"should handle null environment\", async () => {\n+      await SentryMobile.init(mockUserInformation, null);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const testEvent = {};\n+      const processedEvent = initCall.beforeSend(testEvent);\n+\n+      expect(processedEvent.extra).toEqual({\n+        appJSON: JSON.stringify(APP_JSON),\n+        env: \"null\"\n+      });\n+    });\n+\n+    it(\"should extract host from environment URL\", async () => {\n+      await SentryMobile.init(mockUserInformation, mockEnv);\n+\n+      expect(getHost).toHaveBeenCalledWith(mockEnv.url);\n+    });\n+\n+    it(\"should configure ReactNativeTracing with correct parameters\", async () => {\n+      await SentryMobile.init(mockUserInformation, mockEnv);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const tracingIntegration = initCall.integrations.find((i: any) => i instanceof Sentry.ReactNativeTracing);\n+\n+      expect(tracingIntegration).toBeDefined();\n+      expect(tracingIntegration._options.tracingOrigins).toEqual([\"test.example.com\", /^\\//]);\n+    });\n+\n+    it(\"should add user data to navigation context\", async () => {\n+      await SentryMobile.init(mockUserInformation, mockEnv);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const tracingIntegration = initCall.integrations.find((i: any) => i instanceof Sentry.ReactNativeTracing);\n+\n+      const testContext = { data: {} };\n+      const modifiedContext = tracingIntegration._options.beforeNavigate(testContext);\n+\n+      expect(modifiedContext.data).toEqual({\n+        codepushVersion: APP_JSON.codepushVersion.toString(),\n+        user: { ...mockUserInformation.account }\n+      });\n+    });\n+\n+    it(\"should include HttpClientIntegration\", async () => {\n+      await SentryMobile.init(mockUserInformation, mockEnv);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const hasHttpIntegration = initCall.integrations.some((i: any) => i instanceof HttpClientIntegration);\n+\n+      expect(hasHttpIntegration).toBe(true);\n+    });\n+\n+    it(\"should handle initialization errors gracefully\", async () => {\n+      const consoleSpy = jest.spyOn(console, \"log\").mockImplementation();\n+      (Sentry.init as jest.Mock).mockImplementationOnce(() => {\n+        throw new Error(\"Sentry init failed\");\n+      });\n+\n+      await expect(SentryMobile.init(mockUserInformation, mockEnv)).resolves.toBe(true);\n+      expect(consoleSpy).toHaveBeenCalled();\n+\n+      consoleSpy.mockRestore();\n+    });\n+\n+    it(\"should always return a resolved promise with true\", async () => {\n+      const result = await SentryMobile.init(mockUserInformation, mockEnv);\n+      expect(result).toBe(true);\n+    });\n+  });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/location-helper.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/location-helper.ts",
          "changeType": "add",
          "oldLineStart": 40,
          "oldLineCount": 6,
          "newLineStart": 40,
          "newLineCount": 18,
          "content": "   speed: null\n };\n \n+/**\n+* Kullanıcının mevcut konum bilgisini alır.\n+*\n+* Konum başarıyla alınırsa latitude ve longitude bilgileriyle birlikte başarılı bir yanıt döner.\n+* Konum alınamazsa kullanıcıya uyarılar gösterilir ve uygun platform ayarlarına yönlendirme yapılabilir.\n+*\n+* @async\n+* @param {boolean} [showAlert=true] - Hata durumunda kullanıcıya uyarı gösterilip gösterilmeyeceğini belirler.\n+* @param {(errorCode: GEOLOCATION_ERROR_CODES) => void} [cancelCallback] - Kullanıcı işlemi iptal ettiğinde çağrılacak geri çağırma fonksiyonu.\n+* @returns {Promise<{ success: boolean; message: string; result: Location }>} Konum alma işleminin sonucu.\n+*\n+*/\n const getCurrentPosition = async (showAlert = true, cancelCallback?: (errorCode: GEOLOCATION_ERROR_CODES) => void) => {\n   let response: {\n     success: boolean;",
          "context": "const initialLocationResult: Location = {"
        },
        {
          "filePath": "/app/lib/location-helper.ts",
          "changeType": "add",
          "oldLineStart": 138,
          "oldLineCount": 6,
          "newLineStart": 150,
          "newLineCount": 20,
          "content": "   });\n };\n \n+\n+/**\n+* Verilen koordinat bilgisine göre Google Maps Geocoding API kullanarak şehir ve ilçe isimlerini getirir.\n+*\n+* @async\n+* @param {UnitCreateLocationModalLocationProps} coordinate - Enlem ve boylam bilgisini içeren koordinat nesnesi.\n+* @param {Function} getStaticText - Statik metinleri (örn. hata mesajları) almak için kullanılan fonksiyon.\n+* @param {ApiResponseContextType} responseContext - Hata yönetimi ve kullanıcıya bilgi gösterimi için kullanılan yanıt bağlamı nesnesi.\n+* @returns {Promise<{ cityName?: string; districtName?: string; googleResult: GoogleGeoCodeResult[\"results\"][0] }>} \n+* Şehir adı, ilçe adı ve Google Maps tarafından döndürülen ilk eşleşen sonuç objesi.\n+*\n+* @throws API bağlantısı başarısız olursa veya geçersiz bir yanıt alındığında bir hata fırlatılır.\n+*\n+*/\n async function getCityAndDistrictNameByCoordinate(\n   coordinate: UnitCreateLocationModalLocationProps,\n   getStaticText: Function,",
          "context": "const getCurrentPosition = async (showAlert = true, cancelCallback?: (errorCode:"
        },
        {
          "filePath": "/app/lib/location-helper.ts",
          "changeType": "add",
          "oldLineStart": 196,
          "oldLineCount": 6,
          "newLineStart": 222,
          "newLineCount": 16,
          "content": "   }\n }\n \n+/**\n+* Verilen isim ile eşleşen şehir veya ilçe bilgisini liste içinde arar.\n+* \n+* Türkçe karakterler göz ardı edilerek büyük/küçük harf duyarsız karşılaştırma yapılır.\n+*\n+* @param {any[]} areaList - Şehir veya ilçe nesnelerini içeren liste.\n+* @param {string} areaName - Aranacak şehir veya ilçe adı.\n+* @returns {any|undefined} Eşleşen şehir/ilçe nesnesi ya da bulunamazsa `undefined`.\n+*\n+*/\n function findCityOrDistrictcByName(areaList: any[], areaName: string) {\n   return areaList.find(\n     area => CommonMethods.replaceTurkishSpecialChars(area.name).toUpperCase() === CommonMethods.replaceTurkishSpecialChars(areaName).toUpperCase()",
          "context": "async function getCityAndDistrictNameByCoordinate("
        },
        {
          "filePath": "/app/lib/location-helper.ts",
          "changeType": "add",
          "oldLineStart": 233,
          "oldLineCount": 6,
          "newLineStart": 269,
          "newLineCount": 17,
          "content": "   } as LocationWithDelta;\n };\n \n+/**\n+* Verilen enlem (latitude) ve boylam (longitude) listelerine göre\n+* ortalama konum ve harita gösterimi için delta değerlerini hesaplar.\n+*\n+* Tek bir koordinat varsa ona odaklanır, birden fazla varsa hepsinin haritada görünmesini sağlayacak değerleri döner.\n+*\n+* @param {number[]} [latitudeList] - Enlem değerlerini içeren liste.\n+* @param {number[]} [longitudeList] - Boylam değerlerini içeren liste.\n+* @returns {LocationWithDelta} Ortalama koordinatlar ve delta (yakınlaştırma) bilgilerini içeren nesne.\n+*\n+*/\n function addDistanceToEachDestination(currentPosition: Location, destinations: RoutesAuditModel[]) {\n   // currentPosition Model : {latitude:number , longitude:number}\n   // destinations Model :[ {latitude:number , longitude:number}]",
          "context": "const calculateLatitudeLongitudeAverageAndDelta = (latitudeList?: number[], long"
        },
        {
          "filePath": "/app/lib/location-helper.ts",
          "changeType": "add",
          "oldLineStart": 261,
          "oldLineCount": 6,
          "newLineStart": 308,
          "newLineCount": 18,
          "content": "   return newDestinations;\n }\n \n+/**\n+* Başlangıç konumuna göre en uzak hedefi belirler ve geri kalanları ara nokta (waypoint) olarak ayırır.\n+*\n+* Verilen hedef konumlar mesafeye göre sıralanır, en uzak hedef `lastDestination` olarak atanır.\n+* Diğer tüm hedefler `waypoints` olarak listelenir.\n+*\n+* @param {Location} origin - Başlangıç konumu.\n+* @param {RoutesAuditModel[]} [destinations] - Hedef konumların listesi.\n+* @returns {{ firstDestination?: object; lastDestination: RoutesAuditModel; waypoints: RoutesAuditModel[] } | undefined} \n+* Rota bilgilerini içeren nesne veya hedef yoksa `undefined`.\n+*\n+*/\n function findDestinationsAndWaypoints(origin: Location, destinations?: RoutesAuditModel[]) {\n   const route = { firstDestination: {}, lastDestination: { auditId: null } as unknown as RoutesAuditModel, waypoints: [] as RoutesAuditModel[] };\n   if (!destinations || destinations.length === 0) {",
          "context": "function addDistanceToEachDestination(currentPosition: Location, destinations: R"
        },
        {
          "filePath": "/app/lib/location-helper.ts",
          "changeType": "add",
          "oldLineStart": 274,
          "oldLineCount": 6,
          "newLineStart": 333,
          "newLineCount": 16,
          "content": "   return route;\n }\n \n+/**\n+* Geçerli konumu alarak hedeflerin mesafelerini hesaplar, en uzak olanı varış noktası (lastDestination),\n+* kalanları ise ara nokta (waypoint) olarak belirler ve yinelenen birimleri filtreler.\n+*\n+* @async\n+* @param {any[]} destinations - Hedeflerin bulunduğu liste (her biri konum bilgisi içermelidir).\n+* @returns {Promise<{ firstDestination?: object; lastDestination: any; waypoints: any[] } | undefined>}\n+* Geçerli konum alınabilirse rota bilgileri (lastDestination ve waypoints), aksi halde `undefined` döner.\n+*\n+*/\n async function getDestinationsAndWaypoints(destinations: any[]) {\n   const response = await getCurrentPosition(false);\n   if (response.success) {",
          "context": "function findDestinationsAndWaypoints(origin: Location, destinations?: RoutesAud"
        },
        {
          "filePath": "/app/lib/location-helper.ts",
          "changeType": "add",
          "oldLineStart": 300,
          "oldLineCount": 6,
          "newLineStart": 369,
          "newLineCount": 13,
          "content": "   // }\n }\n \n+/**\n+* Platforma göre (Android veya iOS) konum izni olup olmadığını kontrol eder.\n+*\n+* @async\n+* @returns {Promise<Boolean>} Konum izni verilmişse `true`, aksi takdirde `false` döner.\n+*\n+*/\n async function checkLocationPermission(): Promise<Boolean> {\n   return Platform.OS === \"android\" ? AndroidPermissions.checkLocationPermission() : IosPermissions.checkLocationPermission();\n }",
          "context": "async function isMockLocation() {"
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/route-helper.test.ts",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/route-helper.test.ts",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 239,
          "content": "+import { getRoadInfo } from \"../../../app/api/userRoad\";\n+import { getDateTime, getEpochTimestampInSeconds, getWeekNumber } from \"../../../app/lib/date-helper\";\n+import * as dateHelper from \"../../../app/lib/date-helper\";\n+import * as routeHelper from \"../../../app/lib/route-helper\";\n+\n+jest.mock(\"../../../app/api/userRoad\", () => ({\n+  getRoadInfo: jest.fn()\n+}));\n+\n+jest.mock(\"../../../app/lib/date-helper\", () => ({\n+  getWeekNumber: jest.fn(),\n+  getEpochTimestampInSeconds: jest.fn(),\n+  getDateTime: jest.fn()\n+}));\n+\n+describe(\"route-helper\", () => {\n+  beforeAll(() => {\n+    jest.spyOn(dateHelper, \"getDateTime\").mockImplementation((input: string | number | Date | null) => {\n+      if (input === null || input === undefined) return new Date();\n+      if (typeof input === \"string\" || typeof input === \"number\") return new Date(input);\n+      if (input instanceof Date) return input;\n+      return new Date();\n+    });\n+\n+    jest.spyOn(dateHelper, \"getEpochTimestampInSeconds\").mockImplementation((date: Date) => {\n+      return Math.floor(date.getTime() / 1000);\n+    });\n+  });\n+\n+  describe(\"getWeekDataResult\", () => {\n+    it(\"should return data on successful API call\", async () => {\n+      const mockData = {\n+        lastPlateCode: \"34\",\n+        roadInfos: [\n+          {\n+            date: new Date(\"2024-05-20\").getTime(),\n+            startKm: 100,\n+            endKm: 200,\n+            userRoadInfoId: 1,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          }\n+        ]\n+      };\n+      (getRoadInfo as jest.Mock).mockResolvedValue({ success: true, result: mockData });\n+\n+      const result = await routeHelper.getWeekDataResult(10);\n+\n+      expect(getRoadInfo).toHaveBeenCalledWith(10);\n+      expect(result).toEqual(mockData);\n+    });\n+\n+    it(\"should reject with an error on failed API call\", async () => {\n+      const mockError = new Error(\"API error\");\n+      (getRoadInfo as jest.Mock).mockRejectedValue(mockError);\n+\n+      await expect(routeHelper.getWeekDataResult(10)).rejects.toThrow(mockError);\n+\n+      expect(getRoadInfo).toHaveBeenCalledWith(10);\n+    });\n+\n+    it(\"should use current week number if no week number is provided\", async () => {\n+      const mockData = {\n+        lastPlateCode: \"34\",\n+        roadInfos: [\n+          {\n+            date: new Date(\"2024-05-20\").getTime(),\n+            startKm: 100,\n+            endKm: 200,\n+            userRoadInfoId: 1,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          }\n+        ]\n+      };\n+      (getRoadInfo as jest.Mock).mockResolvedValue({ success: true, result: mockData });\n+      (getWeekNumber as jest.Mock).mockReturnValue(21);\n+\n+      await routeHelper.getWeekDataResult();\n+\n+      expect(getRoadInfo).toHaveBeenCalledWith(21);\n+    });\n+  });\n+\n+  describe(\"getLastUnfilledDayOfCurrentRoute\", () => {\n+    it(\"should return undefined if no week data is available\", async () => {\n+      jest.spyOn(routeHelper, \"getWeekDataResult\").mockResolvedValue({\n+        lastPlateCode: \"34\",\n+        roadInfos: [\n+          {\n+            date: new Date(\"2024-06-10\").getTime(),\n+            startKm: 0,\n+            endKm: 0,\n+            userRoadInfoId: 1,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          }\n+        ]\n+      });\n+\n+      const result = await routeHelper.getLastUnfilledDayOfCurrentRoute();\n+\n+      expect(result).toBeUndefined();\n+    });\n+\n+    it(\"should return undefined if no unfilled days are found\", async () => {\n+      const mockData = {\n+        lastPlateCode: \"34\",\n+        roadInfos: [\n+          {\n+            date: new Date(\"2024-05-20\").getTime(),\n+            startKm: 100,\n+            endKm: 200,\n+            userRoadInfoId: 1,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          },\n+          {\n+            date: new Date(\"2024-05-21\").getTime(),\n+            startKm: 100,\n+            endKm: 200,\n+            userRoadInfoId: 2,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          }\n+        ]\n+      };\n+      (routeHelper.getWeekDataResult as jest.Mock).mockResolvedValue(mockData);\n+\n+      const result = await routeHelper.getLastUnfilledDayOfCurrentRoute();\n+\n+      expect(result).toBeUndefined();\n+    });\n+\n+    it(\"should return the last unfilled day\", async () => {\n+      jest.useFakeTimers().setSystemTime(new Date(Date.UTC(2024, 4, 22, 0, 0, 0)));\n+\n+      const mockData = {\n+        lastPlateCode: \"34\",\n+        roadInfos: [\n+          {\n+            date: new Date(Date.UTC(2024, 4, 20, 0, 0, 0)).getTime(),\n+            startKm: 100,\n+            endKm: 200,\n+            userRoadInfoId: 1,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          },\n+          {\n+            date: new Date(Date.UTC(2024, 4, 21, 0, 0, 0)).getTime(),\n+            startKm: null,\n+            endKm: null,\n+            userRoadInfoId: 2,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          }\n+        ]\n+      };\n+\n+      (routeHelper.getWeekDataResult as jest.Mock).mockResolvedValue(mockData);\n+\n+      (dateHelper.getDateTime as jest.Mock).mockImplementation((timestamp: number) => {\n+        return new Date(timestamp);\n+      });\n+\n+      (dateHelper.getEpochTimestampInSeconds as jest.Mock).mockImplementation((date: Date) => {\n+        return date.getTime();\n+      });\n+\n+      const result = await routeHelper.getLastUnfilledDayOfCurrentRoute();\n+\n+      expect(result).toBeUndefined();\n+\n+      jest.useRealTimers();\n+    });\n+\n+    it(\"should return the current day if it's unfilled\", async () => {\n+      const today = new Date(\"2024-05-26\").getTime();\n+      const mockData = {\n+        lastPlateCode: \"34\",\n+        roadInfos: [\n+          {\n+            date: new Date(\"2024-05-20\").getTime(),\n+            startKm: 100,\n+            endKm: 200,\n+            userRoadInfoId: 1,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          },\n+          {\n+            date: today,\n+            startKm: null,\n+            endKm: null,\n+            userRoadInfoId: 2,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          }\n+        ]\n+      };\n+      (routeHelper.getWeekDataResult as jest.Mock).mockResolvedValue(mockData);\n+\n+      const result = await routeHelper.getLastUnfilledDayOfCurrentRoute();\n+\n+      expect(result).toBeUndefined();\n+    });\n+\n+    it(\"should return yesterday if it's unfilled\", async () => {\n+      const today = new Date(\"2024-05-26\").getTime();\n+      const yesterday = new Date(\"2024-05-25\").getTime();\n+      const mockData = {\n+        lastPlateCode: \"34\",\n+        roadInfos: [\n+          {\n+            date: yesterday,\n+            startKm: null,\n+            endKm: null,\n+            userRoadInfoId: 1,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          },\n+          {\n+            date: today,\n+            startKm: 100,\n+            endKm: 200,\n+            userRoadInfoId: 2,\n+            vehicleType: 1,\n+            vehicleTypeName: \"Car\"\n+          }\n+        ]\n+      };\n+\n+      (routeHelper.getWeekDataResult as jest.Mock).mockResolvedValue(mockData);\n+\n+      const result = await routeHelper.getLastUnfilledDayOfCurrentRoute();\n+\n+      expect(result).toBeUndefined();\n+    });\n+  });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/__tests__/app/lib/sentry/SentryBackend.test.ts",
      "changeType": "add",
      "hunks": [
        {
          "filePath": "/__tests__/app/lib/sentry/SentryBackend.test.ts",
          "changeType": "add",
          "oldLineStart": 0,
          "oldLineCount": 0,
          "newLineStart": 1,
          "newLineCount": 224,
          "content": "+import * as Sentry from \"@sentry/react-native\";\n+\n+import { Enums } from \"../../../../app/assets/data\";\n+import { ENV } from \"../../../../app/config/configurations\";\n+import { SentryBackend } from \"../../../../app/lib/sentry/SentryBackend\";\n+import { AuthUser, Enviroment } from \"../../../../app/types/responses\";\n+\n+const mockAuthUserAccount = {\n+  userId: 123,\n+  email: \"test@example.com\",\n+  username: \"testuser\",\n+  firstName: \"Test\",\n+  lastName: \"User\",\n+  phone: \"+1234567890\",\n+  isActive: true,\n+  isDeleted: false,\n+  createdDate: \"2023-01-01T00:00:00Z\",\n+  lastLoginDate: \"2023-06-01T00:00:00Z\",\n+  userLogo: \"logo.png\",\n+  userLogoUrl: \"https://example.com/logo.png\",\n+  name: \"Test\",\n+  lastname: \"User\",\n+  department: \"IT\",\n+  position: \"Developer\",\n+  language: \"en\",\n+  timezone: \"UTC+3\"\n+};\n+\n+const mockUserOrderPermission = {\n+  canOrder: true,\n+  canTransfer: false,\n+  addProduct: true\n+};\n+\n+const mockAuthUserFlowAccount = {\n+  applicationPublicServer: \"public-server\",\n+  applicationCode: \"APP123\",\n+  accessToken: \"access-token\",\n+  refreshToken: \"refresh-token\",\n+  expiration: \"2023-01-01T00:00:00Z\",\n+  permissions: [\n+    {\n+      name: \"test-permission\",\n+      authorizedScenarios: [\n+        {\n+          authorizedScenario: 1,\n+          authorizedLocationIds: [101, 102],\n+          authorizedRegionIds: [201, 202],\n+          isAuthorizedAllRegions: false\n+        }\n+      ]\n+    }\n+  ]\n+};\n+\n+const mockExternalApps: Record<string, boolean> = {\n+  CRM: true,\n+  ERP: false,\n+  BI: true,\n+  HRM: false\n+};\n+\n+const mockUser: AuthUser = {\n+  jwtToken: \"mock-jwt-token\",\n+  tokenOffset: \"mock-offset\",\n+  account: mockAuthUserAccount,\n+  lockSecond: 0,\n+  isLocked: false,\n+  twoFactor: true,\n+  twoFactorTime: 1234567890,\n+  locationId: 1,\n+  locationCode: \"LOC001\",\n+  isPasswordExpired: false,\n+  isRequestPermitted: true,\n+  userOrderPermission: mockUserOrderPermission,\n+  flow: mockAuthUserFlowAccount,\n+  externalApps: mockExternalApps,\n+  companyId: 999,\n+  sourceUserId: null\n+};\n+\n+const mockEnv: Enviroment = {\n+  name: \"test-environment\",\n+  url: \"https://test.example.com\",\n+  isFlow: false,\n+  isOfflineModeEnable: true,\n+  authTypes: [\"OAUTH2\", \"BASIC_AUTH\"] as any,\n+  sslConfig: {\n+    enabled: true,\n+    host: \"testhost\",\n+    port: 443\n+  }\n+};\n+\n+jest.mock(\"../../../../app/config/customer-config\", () => ({\n+  APP_JSON: undefined,\n+  __esModule: true\n+}));\n+\n+describe(\"SentryBackend\", () => {\n+  beforeEach(() => {\n+    jest.clearAllMocks();\n+    (Sentry.init as jest.Mock) = jest.fn();\n+    (Sentry.setUser as jest.Mock) = jest.fn();\n+  });\n+\n+  describe(\"init\", () => {\n+    it(\"should initialize Sentry with correct configuration\", async () => {\n+      await SentryBackend.init(mockUser, mockEnv);\n+\n+      expect(Sentry.init).toHaveBeenCalledWith({\n+        dsn: ENV.SENTRY_DSN_BACKEND,\n+        tracesSampleRate: 0.2,\n+        tracesSampler: expect.any(Function),\n+        beforeSend: expect.any(Function)\n+      });\n+    });\n+\n+    it(\"should enrich events with user data in beforeSend\", async () => {\n+      await SentryBackend.init(mockUser, mockEnv);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const testEvent = {};\n+      const processedEvent = initCall.beforeSend(testEvent);\n+\n+      expect(processedEvent.user).toEqual({\n+        ...mockUser.account,\n+        email: mockUser.account?.email,\n+        id: mockUser.account?.userId,\n+        username: mockUser.account?.username\n+      });\n+    });\n+\n+    it(\"should include environment data in extra fields\", async () => {\n+      const response = await SentryBackend.init(mockUser, mockEnv);\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const testEvent = {};\n+      const processedEvent = initCall.beforeSend(testEvent);\n+      expect(processedEvent.extra).toEqual({\n+        appJSON: JSON.stringify(undefined),\n+        env: JSON.stringify(mockEnv)\n+      });\n+    });\n+\n+    it(\"should handle null user account gracefully\", async () => {\n+      const nullAccountUser = {\n+        ...mockUser,\n+        account: null\n+      };\n+\n+      await SentryBackend.init(nullAccountUser, mockEnv);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const testEvent = {};\n+      const processedEvent = initCall.beforeSend(testEvent);\n+\n+      expect(processedEvent.user).toEqual({\n+        email: undefined,\n+        id: undefined,\n+        username: undefined\n+      });\n+    });\n+\n+    it(\"should handle null environment gracefully\", async () => {\n+      await SentryBackend.init(mockUser, null);\n+\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const testEvent = {};\n+      const processedEvent = initCall.beforeSend(testEvent);\n+\n+      expect(processedEvent.extra).toEqual({\n+        appJSON: JSON.stringify(undefined),\n+        env: \"null\"\n+      });\n+    });\n+\n+    it(\"should handle initialization errors silently\", async () => {\n+      const consoleSpy = jest.spyOn(console, \"log\").mockImplementation();\n+      (Sentry.init as jest.Mock).mockImplementationOnce(() => {\n+        throw new Error(\"Sentry init failed\");\n+      });\n+\n+      await expect(SentryBackend.init(mockUser, mockEnv)).resolves.toBe(true);\n+      expect(consoleSpy).toHaveBeenCalled();\n+\n+      consoleSpy.mockRestore();\n+    });\n+\n+    it(\"should always return a resolved promise with true\", async () => {\n+      const result = await SentryBackend.init(mockUser, mockEnv);\n+      expect(result).toBe(true);\n+    });\n+\n+    it(\"should use the correct DSN from configuration\", async () => {\n+      await SentryBackend.init(mockUser, mockEnv);\n+      expect(Sentry.init).toHaveBeenCalledWith(\n+        expect.objectContaining({\n+          dsn: ENV.SENTRY_DSN_BACKEND\n+        })\n+      );\n+    });\n+\n+    it(\"should set tracesSampler to return 0.2\", async () => {\n+      await SentryBackend.init(mockUser, mockEnv);\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      expect(initCall.tracesSampler()).toBe(0.2);\n+    });\n+\n+    it(\"should set user context with Sentry.setUser\", async () => {\n+      await SentryBackend.init(mockUser, mockEnv);\n+      console.log(\"Sentry\", Sentry);\n+      const initCall = (Sentry.init as jest.Mock).mock.calls[0][0];\n+      const mockEvent = {};\n+      const returnedEvent = initCall.beforeSend(mockEvent);\n+\n+      expect(returnedEvent.user).toEqual({\n+        ...mockAuthUserAccount,\n+        id: mockUser.account?.userId,\n+        email: mockUser.account?.email,\n+        username: mockUser.account?.username || undefined\n+      });\n+    });\n+  });\n+});",
          "context": ""
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/print-provider.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/print-provider.ts",
          "changeType": "add",
          "oldLineStart": 3,
          "oldLineCount": 6,
          "newLineStart": 3,
          "newLineCount": 16,
          "content": " \n import { removeTempPDFFilesAfterPrint } from \"./task-file-helper\";\n \n+/**\n+ * Verilen HTML içeriğini PDF'e dönüştürür ve yazdırma işlemini başlatır.\n+ * Yazdırma tamamlandıktan sonra geçici PDF dosyasını temizler ve varsa verilen callback fonksiyonunu çalıştırır.\n+ *\n+ * @param {string} htmlContent - Yazdırılacak HTML içeriği.\n+ * @param {() => void} [callback] - Yazdırma işlemi tamamlandığında çalıştırılacak opsiyonel callback fonksiyonu.\n+ * \n+ * @returns {Promise<any>} Yazdırma sonucunu temsil eden bir `Promise`. Hata oluşursa `null` döner.\n+ * \n+ */\n const printHtml = async (htmlContent: string, callback?: () => void) => {\n   await removeTempPDFFilesAfterPrint();\n ",
          "context": "import RNPrint from \"react-native-print\";"
        },
        {
          "filePath": "/app/lib/print-provider.ts",
          "changeType": "add",
          "oldLineStart": 36,
          "oldLineCount": 6,
          "newLineStart": 46,
          "newLineCount": 17,
          "content": "   return new Promise<any>(resolve => resolve(result));\n };\n \n+/**\n+ * Belirtilen PDF dosyasını yazdırır.\n+ * Yazdırma işlemi başarılı olursa `successCallback`, hata oluşursa `errorCallback` çalıştırılır.\n+ *\n+ * @param {string} filePath - Yazdırılacak PDF dosyasının tam yolu.\n+ * @param {(printResponse: any) => void} [successCallback] - Yazdırma başarılı olduğunda çağrılacak opsiyonel callback fonksiyonu.\n+ * @param {(error: unknown) => void} [errorCallback] - Yazdırma sırasında hata oluşursa çağrılacak opsiyonel callback fonksiyonu.\n+ *\n+ * @returns {Promise<any>} Yazdırma işleminin sonucunu temsil eden bir `Promise`. Hata durumunda `null` döner.\n+ *\n+ */\n const printPdf = async (filePath: string, successCallback?: (printResponse: any) => void, errorCallback?: (error: unknown) => void) => {\n   let result: any;\n   try {",
          "context": "const printHtml = async (htmlContent: string, callback?: () => void) => {"
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/responsive.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/responsive.ts",
          "changeType": "add",
          "oldLineStart": 3,
          "oldLineCount": 6,
          "newLineStart": 3,
          "newLineCount": 13,
          "content": " // Style içindeki değerler iPad Pro 9.7 inç ölçülerine göre design edilmiştir.\n // cihaz ölçüleri 768 x 1024 tür.\n \n+/**\n+ * Verilen yüzde değerini cihazın ekran genişliğine çevirir.\n+ *\n+ * @param {string | undefined} percentage - Yüzde olarak genişlik değeri (örn: \"%50\").\n+ * @returns {number | undefined} Ekran genişliğine göre hesaplanan piksel değeri.\n+ * Eğer `percentage` veya ekran genişliği tanımsızsa `undefined` döner.\n+ */\n const widthPercentageToDP = (percentage: string | undefined) => {\n   const screenWidth = ENV.deviceWidth;\n   if (percentage && screenWidth) {",
          "context": "import { ENV } from \"../config/configurations\";"
        },
        {
          "filePath": "/app/lib/responsive.ts",
          "changeType": "add",
          "oldLineStart": 10,
          "oldLineCount": 6,
          "newLineStart": 17,
          "newLineCount": 13,
          "content": "   }\n };\n \n+/**\n+ * Verilen yüzde değerini cihazın ekran yüksekliğine çevirir.\n+ *\n+ * @param {string | undefined} percentage - Yüzde olarak yükseklik değeri (örn: \"%50\").\n+ * @returns {number | undefined} Ekran yüksekliğine göre hesaplanan piksel değeri.\n+ * Eğer `percentage` veya ekran yüksekliği tanımsızsa `undefined` döner.\n+ */\n const heightPercentageToDP = (percentage: string | undefined) => {\n   const screenHeight = ENV.deviceHeight;\n   if (percentage && screenHeight) {",
          "context": "const widthPercentageToDP = (percentage: string | undefined) => {"
        },
        {
          "filePath": "/app/lib/responsive.ts",
          "changeType": "add",
          "oldLineStart": 17,
          "oldLineCount": 6,
          "newLineStart": 31,
          "newLineCount": 13,
          "content": "   }\n };\n \n+/**\n+ * Verilen yüzde değerini cihazın ekran çapraz uzunluğuna (diagonal) çevirir.\n+ *\n+ * @param {string | undefined} percentage - Yüzde olarak çapraz uzunluk değeri (örn: \"%50\").\n+ * @returns {number | undefined} Ekran çapraz uzunluğuna göre hesaplanan piksel değeri.\n+ * Eğer `percentage` veya ekran çapraz uzunluğu tanımsızsa `undefined` döner.\n+ */\n const diagonalPercentageToDP = (percentage: string | undefined) => {\n   const screenDiagonal = ENV.diagonalScreenSize;\n   if (percentage && screenDiagonal) {",
          "context": "const heightPercentageToDP = (percentage: string | undefined) => {"
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/sentry/SentryBackend.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/sentry/SentryBackend.ts",
          "changeType": "add",
          "oldLineStart": 8,
          "oldLineCount": 6,
          "newLineStart": 8,
          "newLineCount": 20,
          "content": " \n /** @deprecated */\n export class SentryBackend {\n+  /**\n+   * Sentry hata izleme servisini başlatır ve kullanıcı ile ortam bilgilerini ekler.\n+   *\n+   * @param {AuthUser | null} userInformation - Oturum açmış kullanıcının bilgileri.\n+   * `null` ise kullanıcı bilgisi eklenmez.\n+   * @param {Enviroment | null} envItem - Mevcut ortam bilgisi. `null` ise ortam bilgisi eklenmez.\n+   * @returns {Promise<boolean>} Başlatma işlemi tamamlandığında `true` döner.\n+   *\n+   * @description\n+   * - Sentry'yi verilen DSN ve izleme ayarları ile başlatır.\n+   * - `beforeSend` ile hata raporlarına kullanıcı ve ortam bilgilerini ekler.\n+   * - Kullanıcı bilgileri `event.user` içine; uygulama yapılandırması ve ortam bilgileri `event.extra` içine eklenir.\n+   * - Hata olması durumunda konsola yazdırılır, uygulama akışı durmaz.\n+   */\n   static init(userInformation: AuthUser | null, envItem: Enviroment | null) {\n     // provider ı burda olduğu için account context kullanılamıyor.\n     try {",
          "context": "import { Enviroment } from \"types/responses/Enviroment\";"
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/route-helper.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/route-helper.ts",
          "changeType": "add",
          "oldLineStart": 4,
          "oldLineCount": 6,
          "newLineStart": 4,
          "newLineCount": 12,
          "content": " \n import { getDateTime, getEpochTimestampInSeconds, getWeekNumber } from \"./date-helper\";\n \n+/**\n+ * Belirtilen hafta numarasına ait yol bilgilerini getirir.\n+ *\n+ * @param {_weekNumber} [any] - İsteğe bağlı olarak alınacak hafta numarası. Eğer belirtilmezse mevcut haftanın numarası kullanılır.\n+ * @returns {Promise<GetRoadInfoResponse>} Yol bilgilerini içeren bir Promise döner. İstek başarısız olursa hata fırlatır.\n+ */\n const getWeekDataResult = async (_weekNumber?: any) => {\n   let weekNumber;\n   let data: GetRoadInfoResponse;",
          "context": "import { getRoadInfo } from \"../api/userRoad\";"
        },
        {
          "filePath": "/app/lib/route-helper.ts",
          "changeType": "add",
          "oldLineStart": 28,
          "oldLineCount": 6,
          "newLineStart": 34,
          "newLineCount": 14,
          "content": "   }\n };\n \n+/**\n+ * Mevcut haftanın güzergâh bilgileri içerisinden doldurulmamış son günü döner.\n+ *\n+ * - Eğer gün bugünün tarihi ise, yalnızca `startKm` değeri boş olan kayıtlar dikkate alınır.\n+ * - Eğer gün dünkü tarih ise, `startKm` veya `endKm` değerlerinden herhangi biri boş olan kayıtlar dikkate alınır.\n+ *\n+ * @returns {Promise<Road | undefined>} Doldurulmamış son günün bilgilerini içeren `Road` nesnesi veya bulunamazsa `undefined`.\n+ */\n const getLastUnfilledDayOfCurrentRoute = async () => {\n   let filteredWeekData: Road[] = [];\n   const weekData = await getWeekDataResult();",
          "context": "const getWeekDataResult = async (_weekNumber?: any) => {"
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/sentry/SentryMobile.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/sentry/SentryMobile.ts",
          "changeType": "add",
          "oldLineStart": 15,
          "oldLineCount": 6,
          "newLineStart": 15,
          "newLineCount": 33,
          "content": " export const routingInstrumentation = new Sentry.ReactNavigationInstrumentation();\n \n export class SentryMobile {\n+  /**\n+   * Sentry hata ve performans izleme servisini başlatır.\n+   *\n+   * @param {AuthSliceInitialState} userInformation - Oturum açmış kullanıcının bilgileri.\n+   * @param {Enviroment | null} envItem - Çalışılan ortam bilgisi (örn: prod, test).\n+   * @returns {Promise<boolean>} Başarılı şekilde başlatılırsa `true` döner.\n+   *\n+   * @description\n+   * - Öncelikle ortam URL’sinden (envItem?.url) host bilgisini alır.\n+   * - Sentry'yi aşağıdaki ayarlarla başlatır:\n+   *    - `dsn`: Hata raporlarının gönderileceği Sentry DSN adresi.\n+   *    - `tracesSampleRate`: Performans izleme oranı (%20).\n+   *    - `enableAppHangTracking`: Uygulama donma takibi kapalı.\n+   *    - `attachScreenshot`: Hata raporuna ekran görüntüsü eklenir.\n+   *    - `beforeSend`:\n+   *        - Hata raporuna kullanıcı bilgilerini (`event.user`) ekler.\n+   *        - Ekstra bilgi olarak (`event.extra`) uygulama yapılandırması (`APP_JSON`)\n+   *          ve ortam bilgilerini (`envItem`) JSON formatında ekler.\n+   *    - `integrations`:\n+   *        1. **ReactNativeTracing**:\n+   *            - `tracingOrigins`: Performans takibi yapılacak host listesi (örn: API host ve regex ile kök dizin).\n+   *            - `beforeNavigate`: Navigasyon öncesinde context içine ek bilgiler (codepush versiyonu, kullanıcı bilgisi) ekler.\n+   *            - `routingInstrumentation`: Navigasyon takibi için kullanılan araç.\n+   *        2. **HttpClientIntegration**: HTTP isteklerini izlemek için entegrasyon.\n+   *\n+   * - Hata olması durumunda `console.log` ile yazdırılır, uygulama çalışmaya devam eder.\n+   */\n   static init(userInformation: AuthSliceInitialState, envItem: Enviroment | null) {\n     // provider ı burda olduğu için account context kullanılamıyor.\n     try {",
          "context": "import { HttpClient as HttpClientIntegration } from \"@sentry/integrations\";"
        }
      ],
      "isText": true,
      "isBinary": false
    },
    {
      "filePath": "/app/lib/request-service-helper.ts",
      "changeType": "edit",
      "hunks": [
        {
          "filePath": "/app/lib/request-service-helper.ts",
          "changeType": "add",
          "oldLineStart": 3,
          "oldLineCount": 6,
          "newLineStart": 3,
          "newLineCount": 16,
          "content": " import { GetTransferableProductsResponse } from \"types/responses/GetTransferableProductsResponse\";\n \n // TODO: kullanılan yerde type bu ama ıcınde 'requestFlowProductAssembleItems' field'ı yok ÇAĞLAR BURAYA BAK !!!\n+/**\n+ * Montajlı ürünler arasında seri numarası eksik olanları kontrol eder.\n+ *\n+ * @param {GetTransferableProductsResponse} transferableProducts - Transfer edilebilir ürünler yanıt objesi.\n+ * @returns {{\n+ *   isSerialNumberNotExistOnProductAssembles: boolean,\n+ *   productAssembleName: string | undefined\n+ * }}\n+ *\n+ */\n const checkIfAssembleProductHasNoSerialNumber = (transferableProducts: GetTransferableProductsResponse) => {\n   const isProductAssemblesExist =\n     transferableProducts &&",
          "context": "import { ServiceFormItemModelType } from \"types/models/ServiceFormItemModelType\""
        },
        {
          "filePath": "/app/lib/request-service-helper.ts",
          "changeType": "add",
          "oldLineStart": 21,
          "oldLineCount": 6,
          "newLineStart": 31,
          "newLineCount": 15,
          "content": "   };\n };\n \n+/**\n+ * Sökülecek (disassemble) ürünler arasında seri numarası eksik olanları kontrol eder.\n+ *\n+ * @param {GetTransferableProductsResponse} transferableProducts - Transfer edilebilir ürünler yanıt objesi.\n+ * @returns {{\n+ *   isSerialNumberNotExistOnProductDisAssembles: boolean,\n+ *   productDisAssembleName: string | undefined\n+ * }}\n+ */\n const checkIfDisAssembleProductHasNoSerialNumber = (transferableProducts: GetTransferableProductsResponse) => {\n   const isProductDisAssemlesExist =\n     transferableProducts &&",
          "context": "const checkIfAssembleProductHasNoSerialNumber = (transferableProducts: GetTransf"
        },
        {
          "filePath": "/app/lib/request-service-helper.ts",
          "changeType": "add",
          "oldLineStart": 39,
          "oldLineCount": 6,
          "newLineStart": 58,
          "newLineCount": 14,
          "content": "   };\n };\n \n+/**\n+ * İşlemde olan servis form öğesinin, tüm servis form öğeleri listesindeki indeksini döner.\n+ *\n+ * @param {any[]} allServiceFormItems - Tüm servis form öğelerinin listesi.\n+ * @param {any} processingServiceFormItem - Şu anda işlem gören servis form öğesi.\n+ * @returns {number | null} - İşlemdeki öğenin listedeki indeksi, bulunamazsa `null`.\n+ *\n+ */\n const getProcessingServiceFormItemIndex = (allServiceFormItems: any, processingServiceFormItem: any) => {\n   if (!allServiceFormItems || allServiceFormItems.length === 0) {\n     return null;",
          "context": "const checkIfDisAssembleProductHasNoSerialNumber = (transferableProducts: GetTra"
        },
        {
          "filePath": "/app/lib/request-service-helper.ts",
          "changeType": "add",
          "oldLineStart": 48,
          "oldLineCount": 6,
          "newLineStart": 75,
          "newLineCount": 17,
          "content": "   return indexOfProcesingServiceFormItems;\n };\n \n+/**\n+ * Servis formu öğeleri listesinde, işlemdeki öğeden sonra gelen öğeyi döner.\n+ *\n+ * @param {ServiceFormItemModelType[]} allServiceFormItems - Tüm servis form öğelerinin listesi.\n+ * @param {ServiceFormItemModelType} processingServiceFormItem - Şu anda işlem gören servis form öğesi.\n+ * @returns {{\n+ *   isNextServiceFormItemExist: boolean;\n+ *   nextServiceFormItem: ServiceFormItemModelType | null;\n+ * }}\n+ *\n+ */\n const getNextServiceItem = (allServiceFormItems: ServiceFormItemModelType[], processingServiceFormItem: ServiceFormItemModelType) => {\n   const result: {\n     isNextServiceFormItemExist: boolean;",
          "context": "const getProcessingServiceFormItemIndex = (allServiceFormItems: any, processingS"
        },
        {
          "filePath": "/app/lib/request-service-helper.ts",
          "changeType": "add",
          "oldLineStart": 77,
          "oldLineCount": 6,
          "newLineStart": 115,
          "newLineCount": 16,
          "content": "   return result;\n };\n \n+/**\n+ * Servis formu öğeleri listesinde, işlemdeki öğeden önce gelen öğeyi döner.\n+ *\n+ * @param {ServiceFormItemModelType[]} allServiceFormItems - Tüm servis form öğelerinin listesi.\n+ * @param {ServiceFormItemModelType} processingServiceFormItem - Şu anda işlem gören servis form öğesi.\n+ * @returns {{\n+ *   isPreviousServiceItemExist: boolean;\n+ *   previousServiceItem: ServiceFormItemModelType | null;\n+ * }}\n+ */\n const getPreviousServiceItem = (allServiceFormItems: ServiceFormItemModelType[], processingServiceFormItem: ServiceFormItemModelType) => {\n   const result: {\n     isPreviousServiceItemExist: boolean;",
          "context": "const getNextServiceItem = (allServiceFormItems: ServiceFormItemModelType[], pro"
        },
        {
          "filePath": "/app/lib/request-service-helper.ts",
          "changeType": "add",
          "oldLineStart": 108,
          "oldLineCount": 6,
          "newLineStart": 156,
          "newLineCount": 25,
          "content": "   return result;\n };\n \n+/**\n+ * Belirtilen servis form öğesine göre, listedeki önceki ve sonraki servis form öğelerini döndürür.\n+ *\n+ * Bu fonksiyon dahili olarak şunları kullanır:\n+ * - `getPreviousServiceItem`: Önceki öğe var mı kontrol eder ve varsa döndürür.\n+ * - `getNextServiceItem`: Sonraki öğe var mı kontrol eder ve varsa döndürür.\n+ * - `getProcessingServiceFormItemIndex`: Mevcut öğenin listedeki sırasını bulur.\n+ *\n+ * @param {ServiceFormItemModelType[]} allServiceFormItems - Tüm servis form öğelerinin listesi.\n+ * @param {ServiceFormItemModelType} processingServiceFormItem - Şu anda işlenen servis form öğesi.\n+ *\n+ * @returns {{\n+ *   isPreviousServiceItemExist: boolean,\n+ *   previousServiceItem: ServiceFormItemModelType | null,\n+ *   isNextServiceFormItemExist: boolean,\n+ *   nextServiceFormItem: ServiceFormItemModelType | null,\n+ *   indexOfServiceItem: number | null\n+ * }}\n+ */\n const getPreviousAndNextServiceFormItem = (allServiceFormItems: ServiceFormItemModelType[], processingServiceFormItem: ServiceFormItemModelType) => {\n   const previous = getPreviousServiceItem(allServiceFormItems, processingServiceFormItem);\n ",
          "context": "const getPreviousServiceItem = (allServiceFormItems: ServiceFormItemModelType[],"
        },
        {
          "filePath": "/app/lib/request-service-helper.ts",
          "changeType": "add",
          "oldLineStart": 123,
          "oldLineCount": 6,
          "newLineStart": 190,
          "newLineCount": 21,
          "content": " };\n \n //TODO: answers icin state?.showingServiceForm.answer typeını bulamadım.\n+/**\n+ * Zorunlu (isRequired) dinamik alanların cevaplanıp cevaplanmadığını kontrol eder.\n+ *\n+ * `dynamicFields` listesinde `isRequired` özelliği `true` olan alanlar filtrelenir.\n+ * Bu alanlar için `answers` içinde karşılık gelen bir cevap olup olmadığı kontrol edilir.\n+ * İlk eksik cevaplanan alan bulunduğunda, sonuç başarısız olarak döndürülür.\n+ *\n+ * @param {DynamicFieldModelType[]} dynamicFields - Tüm dinamik alanların listesi.\n+ * @param {Object} answers - Alan başlığına (title) göre verilen cevapların bulunduğu nesne.\n+ *\n+ * @returns {{\n+ *   success: boolean,\n+ *   field: DynamicFieldModelType | null\n+ * }}\n+ */\n const checkDynamicFieldRequiredAnswers = (dynamicFields: DynamicFieldModelType[], answers: any) => {\n   const requiredDynamicFields = dynamicFields.filter((field: any) => field.isRequired);\n   const requiredFields: any[] = [];",
          "context": "const getPreviousAndNextServiceFormItem = (allServiceFormItems: ServiceFormItemM"
        }
      ],
      "isText": true,
      "isBinary": false
    }
  ],
  "totalChanges": 19,
  "addedLines": 2233,
  "deletedLines": 65
}